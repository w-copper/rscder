# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _SH
else:
    import _SH

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



import sys as _sys
if _sys.byteorder == 'little':
    _cv_numpy_endianess = '<'
else:
    _cv_numpy_endianess = '>'

_cv_numpy_typestr_map = {}
_cv_numpy_bla = {}

CV_VERSION_MAJOR = _SH.CV_VERSION_MAJOR
CV_VERSION_MINOR = _SH.CV_VERSION_MINOR
CV_VERSION_REVISION = _SH.CV_VERSION_REVISION
CV_VERSION_STATUS = _SH.CV_VERSION_STATUS
CV_VERSION = _SH.CV_VERSION
CV_MAJOR_VERSION = _SH.CV_MAJOR_VERSION
CV_MINOR_VERSION = _SH.CV_MINOR_VERSION
CV_SUBMINOR_VERSION = _SH.CV_SUBMINOR_VERSION
class DataType_bool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH.DataType_bool_generic_type
    channels = _SH.DataType_bool_channels
    fmt = _SH.DataType_bool_fmt

    def __init__(self):
        _SH.DataType_bool_swiginit(self, _SH.new_DataType_bool())
    __swig_destroy__ = _SH.delete_DataType_bool

# Register DataType_bool in _SH:
_SH.DataType_bool_swigregister(DataType_bool)

class DataType_uchar(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH.DataType_uchar_generic_type
    channels = _SH.DataType_uchar_channels
    fmt = _SH.DataType_uchar_fmt

    def __init__(self):
        _SH.DataType_uchar_swiginit(self, _SH.new_DataType_uchar())
    __swig_destroy__ = _SH.delete_DataType_uchar

# Register DataType_uchar in _SH:
_SH.DataType_uchar_swigregister(DataType_uchar)

class DataType_schar(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH.DataType_schar_generic_type
    channels = _SH.DataType_schar_channels
    fmt = _SH.DataType_schar_fmt

    def __init__(self):
        _SH.DataType_schar_swiginit(self, _SH.new_DataType_schar())
    __swig_destroy__ = _SH.delete_DataType_schar

# Register DataType_schar in _SH:
_SH.DataType_schar_swigregister(DataType_schar)

class DataType_char(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH.DataType_char_generic_type
    channels = _SH.DataType_char_channels
    fmt = _SH.DataType_char_fmt

    def __init__(self):
        _SH.DataType_char_swiginit(self, _SH.new_DataType_char())
    __swig_destroy__ = _SH.delete_DataType_char

# Register DataType_char in _SH:
_SH.DataType_char_swigregister(DataType_char)

class DataType_ushort(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH.DataType_ushort_generic_type
    channels = _SH.DataType_ushort_channels
    fmt = _SH.DataType_ushort_fmt

    def __init__(self):
        _SH.DataType_ushort_swiginit(self, _SH.new_DataType_ushort())
    __swig_destroy__ = _SH.delete_DataType_ushort

# Register DataType_ushort in _SH:
_SH.DataType_ushort_swigregister(DataType_ushort)

class DataType_short(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH.DataType_short_generic_type
    channels = _SH.DataType_short_channels
    fmt = _SH.DataType_short_fmt

    def __init__(self):
        _SH.DataType_short_swiginit(self, _SH.new_DataType_short())
    __swig_destroy__ = _SH.delete_DataType_short

# Register DataType_short in _SH:
_SH.DataType_short_swigregister(DataType_short)

class DataType_int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH.DataType_int_generic_type
    channels = _SH.DataType_int_channels
    fmt = _SH.DataType_int_fmt

    def __init__(self):
        _SH.DataType_int_swiginit(self, _SH.new_DataType_int())
    __swig_destroy__ = _SH.delete_DataType_int

# Register DataType_int in _SH:
_SH.DataType_int_swigregister(DataType_int)

class DataType_float(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH.DataType_float_generic_type
    channels = _SH.DataType_float_channels
    fmt = _SH.DataType_float_fmt

    def __init__(self):
        _SH.DataType_float_swiginit(self, _SH.new_DataType_float())
    __swig_destroy__ = _SH.delete_DataType_float

# Register DataType_float in _SH:
_SH.DataType_float_swigregister(DataType_float)

class DataType_double(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH.DataType_double_generic_type
    channels = _SH.DataType_double_channels
    fmt = _SH.DataType_double_fmt

    def __init__(self):
        _SH.DataType_double_swiginit(self, _SH.new_DataType_double())
    __swig_destroy__ = _SH.delete_DataType_double

# Register DataType_double in _SH:
_SH.DataType_double_swigregister(DataType_double)

class Range(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _SH.Range_swiginit(self, _SH.new_Range(*args))

    def size(self):
        return _SH.Range_size(self)

    def empty(self):
        return _SH.Range_empty(self)

    @staticmethod
    def all():
        return _SH.Range_all()
    start = property(_SH.Range_start_get, _SH.Range_start_set)
    end = property(_SH.Range_end_get, _SH.Range_end_set)
    __swig_destroy__ = _SH.delete_Range

# Register Range in _SH:
_SH.Range_swigregister(Range)

def Range_all():
    return _SH.Range_all()

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SH.delete_SwigPyIterator

    def value(self):
        return _SH.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _SH.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _SH.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _SH.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _SH.SwigPyIterator_equal(self, x)

    def copy(self):
        return _SH.SwigPyIterator_copy(self)

    def next(self):
        return _SH.SwigPyIterator_next(self)

    def __next__(self):
        return _SH.SwigPyIterator___next__(self)

    def previous(self):
        return _SH.SwigPyIterator_previous(self)

    def advance(self, n):
        return _SH.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _SH.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _SH.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _SH.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _SH.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _SH.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _SH.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _SH:
_SH.SwigPyIterator_swigregister(SwigPyIterator)


_array_map = {}

class Matx_AddOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _SH.Matx_AddOp_swiginit(self, _SH.new_Matx_AddOp())
    __swig_destroy__ = _SH.delete_Matx_AddOp

# Register Matx_AddOp in _SH:
_SH.Matx_AddOp_swigregister(Matx_AddOp)

class Matx_SubOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _SH.Matx_SubOp_swiginit(self, _SH.new_Matx_SubOp())
    __swig_destroy__ = _SH.delete_Matx_SubOp

# Register Matx_SubOp in _SH:
_SH.Matx_SubOp_swigregister(Matx_SubOp)

class Matx_ScaleOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _SH.Matx_ScaleOp_swiginit(self, _SH.new_Matx_ScaleOp())
    __swig_destroy__ = _SH.delete_Matx_ScaleOp

# Register Matx_ScaleOp in _SH:
_SH.Matx_ScaleOp_swigregister(Matx_ScaleOp)

class Matx_MulOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _SH.Matx_MulOp_swiginit(self, _SH.new_Matx_MulOp())
    __swig_destroy__ = _SH.delete_Matx_MulOp

# Register Matx_MulOp in _SH:
_SH.Matx_MulOp_swigregister(Matx_MulOp)

class Matx_DivOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _SH.Matx_DivOp_swiginit(self, _SH.new_Matx_DivOp())
    __swig_destroy__ = _SH.delete_Matx_DivOp

# Register Matx_DivOp in _SH:
_SH.Matx_DivOp_swigregister(Matx_DivOp)

class Matx_MatMulOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _SH.Matx_MatMulOp_swiginit(self, _SH.new_Matx_MatMulOp())
    __swig_destroy__ = _SH.delete_Matx_MatMulOp

# Register Matx_MatMulOp in _SH:
_SH.Matx_MatMulOp_swigregister(Matx_MatMulOp)

class Matx_TOp(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _SH.Matx_TOp_swiginit(self, _SH.new_Matx_TOp())
    __swig_destroy__ = _SH.delete_Matx_TOp

# Register Matx_TOp in _SH:
_SH.Matx_TOp_swigregister(Matx_TOp)

class Mat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _SH.delete_Mat

    def row(self, y):
        return _SH.Mat_row(self, y)

    def col(self, x):
        return _SH.Mat_col(self, x)

    def rowRange(self, *args):
        return _SH.Mat_rowRange(self, *args)

    def colRange(self, *args):
        return _SH.Mat_colRange(self, *args)

    def diag(self, d=0):
        return _SH.Mat_diag(self, d)

    def clone(self):
        return _SH.Mat_clone(self)

    def assignTo(self, m, type=-1):
        return _SH.Mat_assignTo(self, m, type)

    def reshape(self, *args):
        return _SH.Mat_reshape(self, *args)

    def create(self, *args):
        return _SH.Mat_create(self, *args)

    def addref(self):
        return _SH.Mat_addref(self)

    def release(self):
        return _SH.Mat_release(self)

    def deallocate(self):
        return _SH.Mat_deallocate(self)

    def copySize(self, m):
        return _SH.Mat_copySize(self, m)

    def reserve(self, sz):
        return _SH.Mat_reserve(self, sz)

    def resize(self, *args):
        return _SH.Mat_resize(self, *args)

    def push_back_(self, elem):
        return _SH.Mat_push_back_(self, elem)

    def push_back(self, m):
        return _SH.Mat_push_back(self, m)

    def pop_back(self, nelems=1):
        return _SH.Mat_pop_back(self, nelems)

    def locateROI(self, wholeSize, ofs):
        return _SH.Mat_locateROI(self, wholeSize, ofs)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH.Mat_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH.Mat___call__(self, *args)

    def isContinuous(self):
        return _SH.Mat_isContinuous(self)

    def isSubmatrix(self):
        return _SH.Mat_isSubmatrix(self)

    def elemSize(self):
        return _SH.Mat_elemSize(self)

    def elemSize1(self):
        return _SH.Mat_elemSize1(self)

    def type(self):
        return _SH.Mat_type(self)

    def depth(self):
        return _SH.Mat_depth(self)

    def channels(self):
        return _SH.Mat_channels(self)

    def step1(self, i=0):
        return _SH.Mat_step1(self, i)

    def empty(self):
        return _SH.Mat_empty(self)

    def total(self):
        return _SH.Mat_total(self)

    def checkVector(self, elemChannels, depth=-1, requireContinuous=True):
        return _SH.Mat_checkVector(self, elemChannels, depth, requireContinuous)

    def ptr(self, *args):
        return _SH.Mat_ptr(self, *args)
    MAGIC_VAL = _SH.Mat_MAGIC_VAL
    AUTO_STEP = _SH.Mat_AUTO_STEP
    CONTINUOUS_FLAG = _SH.Mat_CONTINUOUS_FLAG
    SUBMATRIX_FLAG = _SH.Mat_SUBMATRIX_FLAG
    MAGIC_MASK = _SH.Mat_MAGIC_MASK
    TYPE_MASK = _SH.Mat_TYPE_MASK
    DEPTH_MASK = _SH.Mat_DEPTH_MASK
    flags = property(_SH.Mat_flags_get, _SH.Mat_flags_set)
    dims = property(_SH.Mat_dims_get, _SH.Mat_dims_set)
    rows = property(_SH.Mat_rows_get, _SH.Mat_rows_set)
    cols = property(_SH.Mat_cols_get, _SH.Mat_cols_set)
    data = property(_SH.Mat_data_get, _SH.Mat_data_set)
    datastart = property(_SH.Mat_datastart_get, _SH.Mat_datastart_set)
    dataend = property(_SH.Mat_dataend_get, _SH.Mat_dataend_set)
    datalimit = property(_SH.Mat_datalimit_get, _SH.Mat_datalimit_set)

    def __init__(self, *args):
        _SH.Mat_swiginit(self, _SH.new_Mat(*args))

    def _typestr(self):
        typestr = _depthToDtype(self.depth())
        if typestr[-1] == '1':
            typestr = '|' + typestr
        else:
            typestr = _cv_numpy_endianess + typestr

        return typestr


    @classmethod
    def __get_channels(cls, array):
        if len(array.shape) == 3:
            n_channel = array.shape[2]
            if n_channel == 1:
                raise ValueError("{} expects an one channel numpy ndarray be 2-dimensional.".format(cls))
        elif len(array.shape) == 2:
            n_channel = 1
        else:
            raise ValueError("{} supports only 2 or 3-dimensional numpy ndarray.".format(cls))

        return n_channel


    def __getattribute__(self, name):
        if name == "__array_interface__":
            n_channels = self.channels()
            if n_channels == 1:
                shape = (self.rows, self.cols)
            else:
                shape = (self.rows, self.cols, n_channels)

            return {"shape": shape,
                    "typestr": self._typestr(),
                    "data": (int(self.data), False)}

        else:
            return object.__getattribute__(self, name)

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        dtype = array.__array_interface__['typestr']
        dtype = dtype[1:]

        n_channel = cls.__get_channels(array)

        new_mat = Mat(array.shape[0],
                      array.shape[1],
                      _toCvType(dtype, n_channel),
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH.Mat___str__(self)

# Register Mat in _SH:
_SH.Mat_swigregister(Mat)

class _cv_numpy_sizeof_uint8_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_uint8_t_value

    def __init__(self):
        _SH._cv_numpy_sizeof_uint8_t_swiginit(self, _SH.new__cv_numpy_sizeof_uint8_t())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_uint8_t

# Register _cv_numpy_sizeof_uint8_t in _SH:
_SH._cv_numpy_sizeof_uint8_t_swigregister(_cv_numpy_sizeof_uint8_t)


if _cv_numpy_sizeof_uint8_t.value == 1:
    _cv_numpy_typestr_map["uint8_t"] = "|" +"u" + "1"
else:
    _cv_numpy_typestr_map["uint8_t"] = _cv_numpy_endianess  +"u" + str(_cv_numpy_sizeof_uint8_t.value)

class uint8_tArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _SH.uint8_tArray_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _SH.uint8_tArray___nonzero__(self)

    def __bool__(self):
        return _SH.uint8_tArray___bool__(self)

    def __len__(self):
        return _SH.uint8_tArray___len__(self)

    def __getslice__(self, i, j):
        return _SH.uint8_tArray___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _SH.uint8_tArray___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _SH.uint8_tArray___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _SH.uint8_tArray___delitem__(self, *args)

    def __getitem__(self, *args):
        return _SH.uint8_tArray___getitem__(self, *args)

    def __setitem__(self, *args):
        return _SH.uint8_tArray___setitem__(self, *args)

    def pop(self):
        return _SH.uint8_tArray_pop(self)

    def append(self, x):
        return _SH.uint8_tArray_append(self, x)

    def empty(self):
        return _SH.uint8_tArray_empty(self)

    def size(self):
        return _SH.uint8_tArray_size(self)

    def swap(self, v):
        return _SH.uint8_tArray_swap(self, v)

    def begin(self):
        return _SH.uint8_tArray_begin(self)

    def end(self):
        return _SH.uint8_tArray_end(self)

    def rbegin(self):
        return _SH.uint8_tArray_rbegin(self)

    def rend(self):
        return _SH.uint8_tArray_rend(self)

    def clear(self):
        return _SH.uint8_tArray_clear(self)

    def get_allocator(self):
        return _SH.uint8_tArray_get_allocator(self)

    def pop_back(self):
        return _SH.uint8_tArray_pop_back(self)

    def erase(self, *args):
        return _SH.uint8_tArray_erase(self, *args)

    def __init__(self, *args):
        _SH.uint8_tArray_swiginit(self, _SH.new_uint8_tArray(*args))

    def push_back(self, x):
        return _SH.uint8_tArray_push_back(self, x)

    def front(self):
        return _SH.uint8_tArray_front(self)

    def back(self):
        return _SH.uint8_tArray_back(self)

    def assign(self, n, x):
        return _SH.uint8_tArray_assign(self, n, x)

    def resize(self, *args):
        return _SH.uint8_tArray_resize(self, *args)

    def insert(self, *args):
        return _SH.uint8_tArray_insert(self, *args)

    def reserve(self, n):
        return _SH.uint8_tArray_reserve(self, n)

    def capacity(self):
        return _SH.uint8_tArray_capacity(self)
    __swig_destroy__ = _SH.delete_uint8_tArray

# Register uint8_tArray in _SH:
_SH.uint8_tArray_swigregister(uint8_tArray)


_array_map["uint8_t"] =uint8_tArray

class _Matx_uint8_t_2_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_uint8_t_2_1_rows
    cols = _SH._Matx_uint8_t_2_1_cols
    channels = _SH._Matx_uint8_t_2_1_channels
    shortdim = _SH._Matx_uint8_t_2_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_uint8_t_2_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_uint8_t_2_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_uint8_t_2_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_uint8_t_2_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_uint8_t_2_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_uint8_t_2_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_uint8_t_2_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_uint8_t_2_1_ddot(self, v)

    def t(self):
        return _SH._Matx_uint8_t_2_1_t(self)

    def mul(self, a):
        return _SH._Matx_uint8_t_2_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_uint8_t_2_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_uint8_t_2_1___call__(self, i, j)
    val = property(_SH._Matx_uint8_t_2_1_val_get, _SH._Matx_uint8_t_2_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_uint8_t_2_1_swiginit(self, _SH.new__Matx_uint8_t_2_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_uint8_t_2_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_uint8_t_2_1

# Register _Matx_uint8_t_2_1 in _SH:
_SH._Matx_uint8_t_2_1_swigregister(_Matx_uint8_t_2_1)

def _Matx_uint8_t_2_1_all(alpha):
    return _SH._Matx_uint8_t_2_1_all(alpha)

def _Matx_uint8_t_2_1_zeros():
    return _SH._Matx_uint8_t_2_1_zeros()

def _Matx_uint8_t_2_1_ones():
    return _SH._Matx_uint8_t_2_1_ones()

def _Matx_uint8_t_2_1_eye():
    return _SH._Matx_uint8_t_2_1_eye()

def _Matx_uint8_t_2_1_randu(a, b):
    return _SH._Matx_uint8_t_2_1_randu(a, b)

def _Matx_uint8_t_2_1_randn(a, b):
    return _SH._Matx_uint8_t_2_1_randn(a, b)


Matx21b = _Matx_uint8_t_2_1

class _Vec_uint8_t_2(_Matx_uint8_t_2_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_uint8_t_2_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_uint8_t_2_all(alpha)

    def mul(self, v):
        return _SH._Vec_uint8_t_2_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_uint8_t_2___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_uint8_t_2_swiginit(self, _SH.new__Vec_uint8_t_2(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_uint8_t_2___str__(self)
    __swig_destroy__ = _SH.delete__Vec_uint8_t_2

# Register _Vec_uint8_t_2 in _SH:
_SH._Vec_uint8_t_2_swigregister(_Vec_uint8_t_2)

def _Vec_uint8_t_2_all(alpha):
    return _SH._Vec_uint8_t_2_all(alpha)

class _DataType_Vec_uint8_t_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_uint8_t_2_generic_type
    channels = _SH._DataType_Vec_uint8_t_2_channels
    fmt = _SH._DataType_Vec_uint8_t_2_fmt

    def __init__(self):
        _SH._DataType_Vec_uint8_t_2_swiginit(self, _SH.new__DataType_Vec_uint8_t_2())
    __swig_destroy__ = _SH.delete__DataType_Vec_uint8_t_2

# Register _DataType_Vec_uint8_t_2 in _SH:
_SH._DataType_Vec_uint8_t_2_swigregister(_DataType_Vec_uint8_t_2)


Vec2b = _Vec_uint8_t_2
DataType_Vec2b = _DataType_Vec_uint8_t_2

class _Matx_uint8_t_3_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_uint8_t_3_1_rows
    cols = _SH._Matx_uint8_t_3_1_cols
    channels = _SH._Matx_uint8_t_3_1_channels
    shortdim = _SH._Matx_uint8_t_3_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_uint8_t_3_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_uint8_t_3_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_uint8_t_3_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_uint8_t_3_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_uint8_t_3_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_uint8_t_3_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_uint8_t_3_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_uint8_t_3_1_ddot(self, v)

    def t(self):
        return _SH._Matx_uint8_t_3_1_t(self)

    def mul(self, a):
        return _SH._Matx_uint8_t_3_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_uint8_t_3_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_uint8_t_3_1___call__(self, i, j)
    val = property(_SH._Matx_uint8_t_3_1_val_get, _SH._Matx_uint8_t_3_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_uint8_t_3_1_swiginit(self, _SH.new__Matx_uint8_t_3_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_uint8_t_3_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_uint8_t_3_1

# Register _Matx_uint8_t_3_1 in _SH:
_SH._Matx_uint8_t_3_1_swigregister(_Matx_uint8_t_3_1)

def _Matx_uint8_t_3_1_all(alpha):
    return _SH._Matx_uint8_t_3_1_all(alpha)

def _Matx_uint8_t_3_1_zeros():
    return _SH._Matx_uint8_t_3_1_zeros()

def _Matx_uint8_t_3_1_ones():
    return _SH._Matx_uint8_t_3_1_ones()

def _Matx_uint8_t_3_1_eye():
    return _SH._Matx_uint8_t_3_1_eye()

def _Matx_uint8_t_3_1_randu(a, b):
    return _SH._Matx_uint8_t_3_1_randu(a, b)

def _Matx_uint8_t_3_1_randn(a, b):
    return _SH._Matx_uint8_t_3_1_randn(a, b)


Matx31b = _Matx_uint8_t_3_1

class _Vec_uint8_t_3(_Matx_uint8_t_3_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_uint8_t_3_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_uint8_t_3_all(alpha)

    def mul(self, v):
        return _SH._Vec_uint8_t_3_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_uint8_t_3___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_uint8_t_3_swiginit(self, _SH.new__Vec_uint8_t_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_uint8_t_3___str__(self)
    __swig_destroy__ = _SH.delete__Vec_uint8_t_3

# Register _Vec_uint8_t_3 in _SH:
_SH._Vec_uint8_t_3_swigregister(_Vec_uint8_t_3)

def _Vec_uint8_t_3_all(alpha):
    return _SH._Vec_uint8_t_3_all(alpha)

class _DataType_Vec_uint8_t_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_uint8_t_3_generic_type
    channels = _SH._DataType_Vec_uint8_t_3_channels
    fmt = _SH._DataType_Vec_uint8_t_3_fmt

    def __init__(self):
        _SH._DataType_Vec_uint8_t_3_swiginit(self, _SH.new__DataType_Vec_uint8_t_3())
    __swig_destroy__ = _SH.delete__DataType_Vec_uint8_t_3

# Register _DataType_Vec_uint8_t_3 in _SH:
_SH._DataType_Vec_uint8_t_3_swigregister(_DataType_Vec_uint8_t_3)


Vec3b = _Vec_uint8_t_3
DataType_Vec3b = _DataType_Vec_uint8_t_3

class _Matx_uint8_t_4_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_uint8_t_4_1_rows
    cols = _SH._Matx_uint8_t_4_1_cols
    channels = _SH._Matx_uint8_t_4_1_channels
    shortdim = _SH._Matx_uint8_t_4_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_uint8_t_4_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_uint8_t_4_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_uint8_t_4_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_uint8_t_4_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_uint8_t_4_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_uint8_t_4_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_uint8_t_4_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_uint8_t_4_1_ddot(self, v)

    def t(self):
        return _SH._Matx_uint8_t_4_1_t(self)

    def mul(self, a):
        return _SH._Matx_uint8_t_4_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_uint8_t_4_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_uint8_t_4_1___call__(self, i, j)
    val = property(_SH._Matx_uint8_t_4_1_val_get, _SH._Matx_uint8_t_4_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_uint8_t_4_1_swiginit(self, _SH.new__Matx_uint8_t_4_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_uint8_t_4_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_uint8_t_4_1

# Register _Matx_uint8_t_4_1 in _SH:
_SH._Matx_uint8_t_4_1_swigregister(_Matx_uint8_t_4_1)

def _Matx_uint8_t_4_1_all(alpha):
    return _SH._Matx_uint8_t_4_1_all(alpha)

def _Matx_uint8_t_4_1_zeros():
    return _SH._Matx_uint8_t_4_1_zeros()

def _Matx_uint8_t_4_1_ones():
    return _SH._Matx_uint8_t_4_1_ones()

def _Matx_uint8_t_4_1_eye():
    return _SH._Matx_uint8_t_4_1_eye()

def _Matx_uint8_t_4_1_randu(a, b):
    return _SH._Matx_uint8_t_4_1_randu(a, b)

def _Matx_uint8_t_4_1_randn(a, b):
    return _SH._Matx_uint8_t_4_1_randn(a, b)


Matx41b = _Matx_uint8_t_4_1

class _Vec_uint8_t_4(_Matx_uint8_t_4_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_uint8_t_4_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_uint8_t_4_all(alpha)

    def mul(self, v):
        return _SH._Vec_uint8_t_4_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_uint8_t_4___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_uint8_t_4_swiginit(self, _SH.new__Vec_uint8_t_4(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_uint8_t_4___str__(self)
    __swig_destroy__ = _SH.delete__Vec_uint8_t_4

# Register _Vec_uint8_t_4 in _SH:
_SH._Vec_uint8_t_4_swigregister(_Vec_uint8_t_4)

def _Vec_uint8_t_4_all(alpha):
    return _SH._Vec_uint8_t_4_all(alpha)

class _DataType_Vec_uint8_t_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_uint8_t_4_generic_type
    channels = _SH._DataType_Vec_uint8_t_4_channels
    fmt = _SH._DataType_Vec_uint8_t_4_fmt

    def __init__(self):
        _SH._DataType_Vec_uint8_t_4_swiginit(self, _SH.new__DataType_Vec_uint8_t_4())
    __swig_destroy__ = _SH.delete__DataType_Vec_uint8_t_4

# Register _DataType_Vec_uint8_t_4 in _SH:
_SH._DataType_Vec_uint8_t_4_swigregister(_DataType_Vec_uint8_t_4)


Vec4b = _Vec_uint8_t_4
DataType_Vec4b = _DataType_Vec_uint8_t_4

class _cv_numpy_sizeof_short(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_short_value

    def __init__(self):
        _SH._cv_numpy_sizeof_short_swiginit(self, _SH.new__cv_numpy_sizeof_short())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_short

# Register _cv_numpy_sizeof_short in _SH:
_SH._cv_numpy_sizeof_short_swigregister(_cv_numpy_sizeof_short)


if _cv_numpy_sizeof_short.value == 1:
    _cv_numpy_typestr_map["short"] = "|" +"i" + "1"
else:
    _cv_numpy_typestr_map["short"] = _cv_numpy_endianess  +"i" + str(_cv_numpy_sizeof_short.value)

class shortArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _SH.shortArray_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _SH.shortArray___nonzero__(self)

    def __bool__(self):
        return _SH.shortArray___bool__(self)

    def __len__(self):
        return _SH.shortArray___len__(self)

    def __getslice__(self, i, j):
        return _SH.shortArray___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _SH.shortArray___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _SH.shortArray___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _SH.shortArray___delitem__(self, *args)

    def __getitem__(self, *args):
        return _SH.shortArray___getitem__(self, *args)

    def __setitem__(self, *args):
        return _SH.shortArray___setitem__(self, *args)

    def pop(self):
        return _SH.shortArray_pop(self)

    def append(self, x):
        return _SH.shortArray_append(self, x)

    def empty(self):
        return _SH.shortArray_empty(self)

    def size(self):
        return _SH.shortArray_size(self)

    def swap(self, v):
        return _SH.shortArray_swap(self, v)

    def begin(self):
        return _SH.shortArray_begin(self)

    def end(self):
        return _SH.shortArray_end(self)

    def rbegin(self):
        return _SH.shortArray_rbegin(self)

    def rend(self):
        return _SH.shortArray_rend(self)

    def clear(self):
        return _SH.shortArray_clear(self)

    def get_allocator(self):
        return _SH.shortArray_get_allocator(self)

    def pop_back(self):
        return _SH.shortArray_pop_back(self)

    def erase(self, *args):
        return _SH.shortArray_erase(self, *args)

    def __init__(self, *args):
        _SH.shortArray_swiginit(self, _SH.new_shortArray(*args))

    def push_back(self, x):
        return _SH.shortArray_push_back(self, x)

    def front(self):
        return _SH.shortArray_front(self)

    def back(self):
        return _SH.shortArray_back(self)

    def assign(self, n, x):
        return _SH.shortArray_assign(self, n, x)

    def resize(self, *args):
        return _SH.shortArray_resize(self, *args)

    def insert(self, *args):
        return _SH.shortArray_insert(self, *args)

    def reserve(self, n):
        return _SH.shortArray_reserve(self, n)

    def capacity(self):
        return _SH.shortArray_capacity(self)
    __swig_destroy__ = _SH.delete_shortArray

# Register shortArray in _SH:
_SH.shortArray_swigregister(shortArray)


_array_map["short"] =shortArray

class _Matx_short_2_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_short_2_1_rows
    cols = _SH._Matx_short_2_1_cols
    channels = _SH._Matx_short_2_1_channels
    shortdim = _SH._Matx_short_2_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_short_2_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_short_2_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_short_2_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_short_2_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_short_2_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_short_2_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_short_2_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_short_2_1_ddot(self, v)

    def t(self):
        return _SH._Matx_short_2_1_t(self)

    def mul(self, a):
        return _SH._Matx_short_2_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_short_2_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_short_2_1___call__(self, i, j)
    val = property(_SH._Matx_short_2_1_val_get, _SH._Matx_short_2_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_short_2_1_swiginit(self, _SH.new__Matx_short_2_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_short_2_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_short_2_1

# Register _Matx_short_2_1 in _SH:
_SH._Matx_short_2_1_swigregister(_Matx_short_2_1)

def _Matx_short_2_1_all(alpha):
    return _SH._Matx_short_2_1_all(alpha)

def _Matx_short_2_1_zeros():
    return _SH._Matx_short_2_1_zeros()

def _Matx_short_2_1_ones():
    return _SH._Matx_short_2_1_ones()

def _Matx_short_2_1_eye():
    return _SH._Matx_short_2_1_eye()

def _Matx_short_2_1_randu(a, b):
    return _SH._Matx_short_2_1_randu(a, b)

def _Matx_short_2_1_randn(a, b):
    return _SH._Matx_short_2_1_randn(a, b)


Matx21s = _Matx_short_2_1

class _Vec_short_2(_Matx_short_2_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_short_2_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_short_2_all(alpha)

    def mul(self, v):
        return _SH._Vec_short_2_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_short_2___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_short_2_swiginit(self, _SH.new__Vec_short_2(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_short_2___str__(self)
    __swig_destroy__ = _SH.delete__Vec_short_2

# Register _Vec_short_2 in _SH:
_SH._Vec_short_2_swigregister(_Vec_short_2)

def _Vec_short_2_all(alpha):
    return _SH._Vec_short_2_all(alpha)

class _DataType_Vec_short_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_short_2_generic_type
    channels = _SH._DataType_Vec_short_2_channels
    fmt = _SH._DataType_Vec_short_2_fmt

    def __init__(self):
        _SH._DataType_Vec_short_2_swiginit(self, _SH.new__DataType_Vec_short_2())
    __swig_destroy__ = _SH.delete__DataType_Vec_short_2

# Register _DataType_Vec_short_2 in _SH:
_SH._DataType_Vec_short_2_swigregister(_DataType_Vec_short_2)


Vec2s = _Vec_short_2
DataType_Vec2s = _DataType_Vec_short_2

class _Matx_short_3_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_short_3_1_rows
    cols = _SH._Matx_short_3_1_cols
    channels = _SH._Matx_short_3_1_channels
    shortdim = _SH._Matx_short_3_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_short_3_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_short_3_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_short_3_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_short_3_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_short_3_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_short_3_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_short_3_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_short_3_1_ddot(self, v)

    def t(self):
        return _SH._Matx_short_3_1_t(self)

    def mul(self, a):
        return _SH._Matx_short_3_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_short_3_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_short_3_1___call__(self, i, j)
    val = property(_SH._Matx_short_3_1_val_get, _SH._Matx_short_3_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_short_3_1_swiginit(self, _SH.new__Matx_short_3_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_short_3_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_short_3_1

# Register _Matx_short_3_1 in _SH:
_SH._Matx_short_3_1_swigregister(_Matx_short_3_1)

def _Matx_short_3_1_all(alpha):
    return _SH._Matx_short_3_1_all(alpha)

def _Matx_short_3_1_zeros():
    return _SH._Matx_short_3_1_zeros()

def _Matx_short_3_1_ones():
    return _SH._Matx_short_3_1_ones()

def _Matx_short_3_1_eye():
    return _SH._Matx_short_3_1_eye()

def _Matx_short_3_1_randu(a, b):
    return _SH._Matx_short_3_1_randu(a, b)

def _Matx_short_3_1_randn(a, b):
    return _SH._Matx_short_3_1_randn(a, b)


Matx31s = _Matx_short_3_1

class _Vec_short_3(_Matx_short_3_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_short_3_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_short_3_all(alpha)

    def mul(self, v):
        return _SH._Vec_short_3_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_short_3___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_short_3_swiginit(self, _SH.new__Vec_short_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_short_3___str__(self)
    __swig_destroy__ = _SH.delete__Vec_short_3

# Register _Vec_short_3 in _SH:
_SH._Vec_short_3_swigregister(_Vec_short_3)

def _Vec_short_3_all(alpha):
    return _SH._Vec_short_3_all(alpha)

class _DataType_Vec_short_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_short_3_generic_type
    channels = _SH._DataType_Vec_short_3_channels
    fmt = _SH._DataType_Vec_short_3_fmt

    def __init__(self):
        _SH._DataType_Vec_short_3_swiginit(self, _SH.new__DataType_Vec_short_3())
    __swig_destroy__ = _SH.delete__DataType_Vec_short_3

# Register _DataType_Vec_short_3 in _SH:
_SH._DataType_Vec_short_3_swigregister(_DataType_Vec_short_3)


Vec3s = _Vec_short_3
DataType_Vec3s = _DataType_Vec_short_3

class _Matx_short_4_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_short_4_1_rows
    cols = _SH._Matx_short_4_1_cols
    channels = _SH._Matx_short_4_1_channels
    shortdim = _SH._Matx_short_4_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_short_4_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_short_4_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_short_4_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_short_4_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_short_4_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_short_4_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_short_4_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_short_4_1_ddot(self, v)

    def t(self):
        return _SH._Matx_short_4_1_t(self)

    def mul(self, a):
        return _SH._Matx_short_4_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_short_4_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_short_4_1___call__(self, i, j)
    val = property(_SH._Matx_short_4_1_val_get, _SH._Matx_short_4_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_short_4_1_swiginit(self, _SH.new__Matx_short_4_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_short_4_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_short_4_1

# Register _Matx_short_4_1 in _SH:
_SH._Matx_short_4_1_swigregister(_Matx_short_4_1)

def _Matx_short_4_1_all(alpha):
    return _SH._Matx_short_4_1_all(alpha)

def _Matx_short_4_1_zeros():
    return _SH._Matx_short_4_1_zeros()

def _Matx_short_4_1_ones():
    return _SH._Matx_short_4_1_ones()

def _Matx_short_4_1_eye():
    return _SH._Matx_short_4_1_eye()

def _Matx_short_4_1_randu(a, b):
    return _SH._Matx_short_4_1_randu(a, b)

def _Matx_short_4_1_randn(a, b):
    return _SH._Matx_short_4_1_randn(a, b)


Matx41s = _Matx_short_4_1

class _Vec_short_4(_Matx_short_4_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_short_4_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_short_4_all(alpha)

    def mul(self, v):
        return _SH._Vec_short_4_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_short_4___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_short_4_swiginit(self, _SH.new__Vec_short_4(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_short_4___str__(self)
    __swig_destroy__ = _SH.delete__Vec_short_4

# Register _Vec_short_4 in _SH:
_SH._Vec_short_4_swigregister(_Vec_short_4)

def _Vec_short_4_all(alpha):
    return _SH._Vec_short_4_all(alpha)

class _DataType_Vec_short_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_short_4_generic_type
    channels = _SH._DataType_Vec_short_4_channels
    fmt = _SH._DataType_Vec_short_4_fmt

    def __init__(self):
        _SH._DataType_Vec_short_4_swiginit(self, _SH.new__DataType_Vec_short_4())
    __swig_destroy__ = _SH.delete__DataType_Vec_short_4

# Register _DataType_Vec_short_4 in _SH:
_SH._DataType_Vec_short_4_swigregister(_DataType_Vec_short_4)


Vec4s = _Vec_short_4
DataType_Vec4s = _DataType_Vec_short_4

class _cv_numpy_sizeof_ushort(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_ushort_value

    def __init__(self):
        _SH._cv_numpy_sizeof_ushort_swiginit(self, _SH.new__cv_numpy_sizeof_ushort())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_ushort

# Register _cv_numpy_sizeof_ushort in _SH:
_SH._cv_numpy_sizeof_ushort_swigregister(_cv_numpy_sizeof_ushort)


if _cv_numpy_sizeof_ushort.value == 1:
    _cv_numpy_typestr_map["ushort"] = "|" +"u" + "1"
else:
    _cv_numpy_typestr_map["ushort"] = _cv_numpy_endianess  +"u" + str(_cv_numpy_sizeof_ushort.value)

class ushortArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _SH.ushortArray_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _SH.ushortArray___nonzero__(self)

    def __bool__(self):
        return _SH.ushortArray___bool__(self)

    def __len__(self):
        return _SH.ushortArray___len__(self)

    def __getslice__(self, i, j):
        return _SH.ushortArray___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _SH.ushortArray___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _SH.ushortArray___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _SH.ushortArray___delitem__(self, *args)

    def __getitem__(self, *args):
        return _SH.ushortArray___getitem__(self, *args)

    def __setitem__(self, *args):
        return _SH.ushortArray___setitem__(self, *args)

    def pop(self):
        return _SH.ushortArray_pop(self)

    def append(self, x):
        return _SH.ushortArray_append(self, x)

    def empty(self):
        return _SH.ushortArray_empty(self)

    def size(self):
        return _SH.ushortArray_size(self)

    def swap(self, v):
        return _SH.ushortArray_swap(self, v)

    def begin(self):
        return _SH.ushortArray_begin(self)

    def end(self):
        return _SH.ushortArray_end(self)

    def rbegin(self):
        return _SH.ushortArray_rbegin(self)

    def rend(self):
        return _SH.ushortArray_rend(self)

    def clear(self):
        return _SH.ushortArray_clear(self)

    def get_allocator(self):
        return _SH.ushortArray_get_allocator(self)

    def pop_back(self):
        return _SH.ushortArray_pop_back(self)

    def erase(self, *args):
        return _SH.ushortArray_erase(self, *args)

    def __init__(self, *args):
        _SH.ushortArray_swiginit(self, _SH.new_ushortArray(*args))

    def push_back(self, x):
        return _SH.ushortArray_push_back(self, x)

    def front(self):
        return _SH.ushortArray_front(self)

    def back(self):
        return _SH.ushortArray_back(self)

    def assign(self, n, x):
        return _SH.ushortArray_assign(self, n, x)

    def resize(self, *args):
        return _SH.ushortArray_resize(self, *args)

    def insert(self, *args):
        return _SH.ushortArray_insert(self, *args)

    def reserve(self, n):
        return _SH.ushortArray_reserve(self, n)

    def capacity(self):
        return _SH.ushortArray_capacity(self)
    __swig_destroy__ = _SH.delete_ushortArray

# Register ushortArray in _SH:
_SH.ushortArray_swigregister(ushortArray)


_array_map["ushort"] =ushortArray

class _Matx_ushort_2_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_ushort_2_1_rows
    cols = _SH._Matx_ushort_2_1_cols
    channels = _SH._Matx_ushort_2_1_channels
    shortdim = _SH._Matx_ushort_2_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_ushort_2_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_ushort_2_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_ushort_2_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_ushort_2_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_ushort_2_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_ushort_2_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_ushort_2_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_ushort_2_1_ddot(self, v)

    def t(self):
        return _SH._Matx_ushort_2_1_t(self)

    def mul(self, a):
        return _SH._Matx_ushort_2_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_ushort_2_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_ushort_2_1___call__(self, i, j)
    val = property(_SH._Matx_ushort_2_1_val_get, _SH._Matx_ushort_2_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_ushort_2_1_swiginit(self, _SH.new__Matx_ushort_2_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_ushort_2_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_ushort_2_1

# Register _Matx_ushort_2_1 in _SH:
_SH._Matx_ushort_2_1_swigregister(_Matx_ushort_2_1)

def _Matx_ushort_2_1_all(alpha):
    return _SH._Matx_ushort_2_1_all(alpha)

def _Matx_ushort_2_1_zeros():
    return _SH._Matx_ushort_2_1_zeros()

def _Matx_ushort_2_1_ones():
    return _SH._Matx_ushort_2_1_ones()

def _Matx_ushort_2_1_eye():
    return _SH._Matx_ushort_2_1_eye()

def _Matx_ushort_2_1_randu(a, b):
    return _SH._Matx_ushort_2_1_randu(a, b)

def _Matx_ushort_2_1_randn(a, b):
    return _SH._Matx_ushort_2_1_randn(a, b)


Matx21w = _Matx_ushort_2_1

class _Vec_ushort_2(_Matx_ushort_2_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_ushort_2_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_ushort_2_all(alpha)

    def mul(self, v):
        return _SH._Vec_ushort_2_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_ushort_2___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_ushort_2_swiginit(self, _SH.new__Vec_ushort_2(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_ushort_2___str__(self)
    __swig_destroy__ = _SH.delete__Vec_ushort_2

# Register _Vec_ushort_2 in _SH:
_SH._Vec_ushort_2_swigregister(_Vec_ushort_2)

def _Vec_ushort_2_all(alpha):
    return _SH._Vec_ushort_2_all(alpha)

class _DataType_Vec_ushort_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_ushort_2_generic_type
    channels = _SH._DataType_Vec_ushort_2_channels
    fmt = _SH._DataType_Vec_ushort_2_fmt

    def __init__(self):
        _SH._DataType_Vec_ushort_2_swiginit(self, _SH.new__DataType_Vec_ushort_2())
    __swig_destroy__ = _SH.delete__DataType_Vec_ushort_2

# Register _DataType_Vec_ushort_2 in _SH:
_SH._DataType_Vec_ushort_2_swigregister(_DataType_Vec_ushort_2)


Vec2w = _Vec_ushort_2
DataType_Vec2w = _DataType_Vec_ushort_2

class _Matx_ushort_3_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_ushort_3_1_rows
    cols = _SH._Matx_ushort_3_1_cols
    channels = _SH._Matx_ushort_3_1_channels
    shortdim = _SH._Matx_ushort_3_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_ushort_3_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_ushort_3_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_ushort_3_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_ushort_3_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_ushort_3_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_ushort_3_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_ushort_3_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_ushort_3_1_ddot(self, v)

    def t(self):
        return _SH._Matx_ushort_3_1_t(self)

    def mul(self, a):
        return _SH._Matx_ushort_3_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_ushort_3_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_ushort_3_1___call__(self, i, j)
    val = property(_SH._Matx_ushort_3_1_val_get, _SH._Matx_ushort_3_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_ushort_3_1_swiginit(self, _SH.new__Matx_ushort_3_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_ushort_3_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_ushort_3_1

# Register _Matx_ushort_3_1 in _SH:
_SH._Matx_ushort_3_1_swigregister(_Matx_ushort_3_1)

def _Matx_ushort_3_1_all(alpha):
    return _SH._Matx_ushort_3_1_all(alpha)

def _Matx_ushort_3_1_zeros():
    return _SH._Matx_ushort_3_1_zeros()

def _Matx_ushort_3_1_ones():
    return _SH._Matx_ushort_3_1_ones()

def _Matx_ushort_3_1_eye():
    return _SH._Matx_ushort_3_1_eye()

def _Matx_ushort_3_1_randu(a, b):
    return _SH._Matx_ushort_3_1_randu(a, b)

def _Matx_ushort_3_1_randn(a, b):
    return _SH._Matx_ushort_3_1_randn(a, b)


Matx31w = _Matx_ushort_3_1

class _Vec_ushort_3(_Matx_ushort_3_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_ushort_3_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_ushort_3_all(alpha)

    def mul(self, v):
        return _SH._Vec_ushort_3_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_ushort_3___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_ushort_3_swiginit(self, _SH.new__Vec_ushort_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_ushort_3___str__(self)
    __swig_destroy__ = _SH.delete__Vec_ushort_3

# Register _Vec_ushort_3 in _SH:
_SH._Vec_ushort_3_swigregister(_Vec_ushort_3)

def _Vec_ushort_3_all(alpha):
    return _SH._Vec_ushort_3_all(alpha)

class _DataType_Vec_ushort_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_ushort_3_generic_type
    channels = _SH._DataType_Vec_ushort_3_channels
    fmt = _SH._DataType_Vec_ushort_3_fmt

    def __init__(self):
        _SH._DataType_Vec_ushort_3_swiginit(self, _SH.new__DataType_Vec_ushort_3())
    __swig_destroy__ = _SH.delete__DataType_Vec_ushort_3

# Register _DataType_Vec_ushort_3 in _SH:
_SH._DataType_Vec_ushort_3_swigregister(_DataType_Vec_ushort_3)


Vec3w = _Vec_ushort_3
DataType_Vec3w = _DataType_Vec_ushort_3

class _Matx_ushort_4_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_ushort_4_1_rows
    cols = _SH._Matx_ushort_4_1_cols
    channels = _SH._Matx_ushort_4_1_channels
    shortdim = _SH._Matx_ushort_4_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_ushort_4_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_ushort_4_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_ushort_4_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_ushort_4_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_ushort_4_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_ushort_4_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_ushort_4_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_ushort_4_1_ddot(self, v)

    def t(self):
        return _SH._Matx_ushort_4_1_t(self)

    def mul(self, a):
        return _SH._Matx_ushort_4_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_ushort_4_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_ushort_4_1___call__(self, i, j)
    val = property(_SH._Matx_ushort_4_1_val_get, _SH._Matx_ushort_4_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_ushort_4_1_swiginit(self, _SH.new__Matx_ushort_4_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_ushort_4_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_ushort_4_1

# Register _Matx_ushort_4_1 in _SH:
_SH._Matx_ushort_4_1_swigregister(_Matx_ushort_4_1)

def _Matx_ushort_4_1_all(alpha):
    return _SH._Matx_ushort_4_1_all(alpha)

def _Matx_ushort_4_1_zeros():
    return _SH._Matx_ushort_4_1_zeros()

def _Matx_ushort_4_1_ones():
    return _SH._Matx_ushort_4_1_ones()

def _Matx_ushort_4_1_eye():
    return _SH._Matx_ushort_4_1_eye()

def _Matx_ushort_4_1_randu(a, b):
    return _SH._Matx_ushort_4_1_randu(a, b)

def _Matx_ushort_4_1_randn(a, b):
    return _SH._Matx_ushort_4_1_randn(a, b)


Matx41w = _Matx_ushort_4_1

class _Vec_ushort_4(_Matx_ushort_4_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_ushort_4_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_ushort_4_all(alpha)

    def mul(self, v):
        return _SH._Vec_ushort_4_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_ushort_4___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_ushort_4_swiginit(self, _SH.new__Vec_ushort_4(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_ushort_4___str__(self)
    __swig_destroy__ = _SH.delete__Vec_ushort_4

# Register _Vec_ushort_4 in _SH:
_SH._Vec_ushort_4_swigregister(_Vec_ushort_4)

def _Vec_ushort_4_all(alpha):
    return _SH._Vec_ushort_4_all(alpha)

class _DataType_Vec_ushort_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_ushort_4_generic_type
    channels = _SH._DataType_Vec_ushort_4_channels
    fmt = _SH._DataType_Vec_ushort_4_fmt

    def __init__(self):
        _SH._DataType_Vec_ushort_4_swiginit(self, _SH.new__DataType_Vec_ushort_4())
    __swig_destroy__ = _SH.delete__DataType_Vec_ushort_4

# Register _DataType_Vec_ushort_4 in _SH:
_SH._DataType_Vec_ushort_4_swigregister(_DataType_Vec_ushort_4)


Vec4w = _Vec_ushort_4
DataType_Vec4w = _DataType_Vec_ushort_4

class _cv_numpy_sizeof_int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_int_value

    def __init__(self):
        _SH._cv_numpy_sizeof_int_swiginit(self, _SH.new__cv_numpy_sizeof_int())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_int

# Register _cv_numpy_sizeof_int in _SH:
_SH._cv_numpy_sizeof_int_swigregister(_cv_numpy_sizeof_int)


if _cv_numpy_sizeof_int.value == 1:
    _cv_numpy_typestr_map["int"] = "|" +"i" + "1"
else:
    _cv_numpy_typestr_map["int"] = _cv_numpy_endianess  +"i" + str(_cv_numpy_sizeof_int.value)

class intArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _SH.intArray_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _SH.intArray___nonzero__(self)

    def __bool__(self):
        return _SH.intArray___bool__(self)

    def __len__(self):
        return _SH.intArray___len__(self)

    def __getslice__(self, i, j):
        return _SH.intArray___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _SH.intArray___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _SH.intArray___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _SH.intArray___delitem__(self, *args)

    def __getitem__(self, *args):
        return _SH.intArray___getitem__(self, *args)

    def __setitem__(self, *args):
        return _SH.intArray___setitem__(self, *args)

    def pop(self):
        return _SH.intArray_pop(self)

    def append(self, x):
        return _SH.intArray_append(self, x)

    def empty(self):
        return _SH.intArray_empty(self)

    def size(self):
        return _SH.intArray_size(self)

    def swap(self, v):
        return _SH.intArray_swap(self, v)

    def begin(self):
        return _SH.intArray_begin(self)

    def end(self):
        return _SH.intArray_end(self)

    def rbegin(self):
        return _SH.intArray_rbegin(self)

    def rend(self):
        return _SH.intArray_rend(self)

    def clear(self):
        return _SH.intArray_clear(self)

    def get_allocator(self):
        return _SH.intArray_get_allocator(self)

    def pop_back(self):
        return _SH.intArray_pop_back(self)

    def erase(self, *args):
        return _SH.intArray_erase(self, *args)

    def __init__(self, *args):
        _SH.intArray_swiginit(self, _SH.new_intArray(*args))

    def push_back(self, x):
        return _SH.intArray_push_back(self, x)

    def front(self):
        return _SH.intArray_front(self)

    def back(self):
        return _SH.intArray_back(self)

    def assign(self, n, x):
        return _SH.intArray_assign(self, n, x)

    def resize(self, *args):
        return _SH.intArray_resize(self, *args)

    def insert(self, *args):
        return _SH.intArray_insert(self, *args)

    def reserve(self, n):
        return _SH.intArray_reserve(self, n)

    def capacity(self):
        return _SH.intArray_capacity(self)
    __swig_destroy__ = _SH.delete_intArray

# Register intArray in _SH:
_SH.intArray_swigregister(intArray)


_array_map["int"] =intArray

class _Matx_int_2_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_int_2_1_rows
    cols = _SH._Matx_int_2_1_cols
    channels = _SH._Matx_int_2_1_channels
    shortdim = _SH._Matx_int_2_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_int_2_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_int_2_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_int_2_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_int_2_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_int_2_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_int_2_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_int_2_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_int_2_1_ddot(self, v)

    def t(self):
        return _SH._Matx_int_2_1_t(self)

    def mul(self, a):
        return _SH._Matx_int_2_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_int_2_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_int_2_1___call__(self, i, j)
    val = property(_SH._Matx_int_2_1_val_get, _SH._Matx_int_2_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_int_2_1_swiginit(self, _SH.new__Matx_int_2_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_int_2_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_int_2_1

# Register _Matx_int_2_1 in _SH:
_SH._Matx_int_2_1_swigregister(_Matx_int_2_1)

def _Matx_int_2_1_all(alpha):
    return _SH._Matx_int_2_1_all(alpha)

def _Matx_int_2_1_zeros():
    return _SH._Matx_int_2_1_zeros()

def _Matx_int_2_1_ones():
    return _SH._Matx_int_2_1_ones()

def _Matx_int_2_1_eye():
    return _SH._Matx_int_2_1_eye()

def _Matx_int_2_1_randu(a, b):
    return _SH._Matx_int_2_1_randu(a, b)

def _Matx_int_2_1_randn(a, b):
    return _SH._Matx_int_2_1_randn(a, b)


Matx21i = _Matx_int_2_1

class _Vec_int_2(_Matx_int_2_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_int_2_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_int_2_all(alpha)

    def mul(self, v):
        return _SH._Vec_int_2_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_int_2___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_int_2_swiginit(self, _SH.new__Vec_int_2(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_int_2___str__(self)
    __swig_destroy__ = _SH.delete__Vec_int_2

# Register _Vec_int_2 in _SH:
_SH._Vec_int_2_swigregister(_Vec_int_2)

def _Vec_int_2_all(alpha):
    return _SH._Vec_int_2_all(alpha)

class _DataType_Vec_int_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_int_2_generic_type
    channels = _SH._DataType_Vec_int_2_channels
    fmt = _SH._DataType_Vec_int_2_fmt

    def __init__(self):
        _SH._DataType_Vec_int_2_swiginit(self, _SH.new__DataType_Vec_int_2())
    __swig_destroy__ = _SH.delete__DataType_Vec_int_2

# Register _DataType_Vec_int_2 in _SH:
_SH._DataType_Vec_int_2_swigregister(_DataType_Vec_int_2)


Vec2i = _Vec_int_2
DataType_Vec2i = _DataType_Vec_int_2

class _Matx_int_3_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_int_3_1_rows
    cols = _SH._Matx_int_3_1_cols
    channels = _SH._Matx_int_3_1_channels
    shortdim = _SH._Matx_int_3_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_int_3_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_int_3_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_int_3_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_int_3_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_int_3_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_int_3_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_int_3_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_int_3_1_ddot(self, v)

    def t(self):
        return _SH._Matx_int_3_1_t(self)

    def mul(self, a):
        return _SH._Matx_int_3_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_int_3_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_int_3_1___call__(self, i, j)
    val = property(_SH._Matx_int_3_1_val_get, _SH._Matx_int_3_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_int_3_1_swiginit(self, _SH.new__Matx_int_3_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_int_3_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_int_3_1

# Register _Matx_int_3_1 in _SH:
_SH._Matx_int_3_1_swigregister(_Matx_int_3_1)

def _Matx_int_3_1_all(alpha):
    return _SH._Matx_int_3_1_all(alpha)

def _Matx_int_3_1_zeros():
    return _SH._Matx_int_3_1_zeros()

def _Matx_int_3_1_ones():
    return _SH._Matx_int_3_1_ones()

def _Matx_int_3_1_eye():
    return _SH._Matx_int_3_1_eye()

def _Matx_int_3_1_randu(a, b):
    return _SH._Matx_int_3_1_randu(a, b)

def _Matx_int_3_1_randn(a, b):
    return _SH._Matx_int_3_1_randn(a, b)


Matx31i = _Matx_int_3_1

class _Vec_int_3(_Matx_int_3_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_int_3_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_int_3_all(alpha)

    def mul(self, v):
        return _SH._Vec_int_3_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_int_3___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_int_3_swiginit(self, _SH.new__Vec_int_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_int_3___str__(self)
    __swig_destroy__ = _SH.delete__Vec_int_3

# Register _Vec_int_3 in _SH:
_SH._Vec_int_3_swigregister(_Vec_int_3)

def _Vec_int_3_all(alpha):
    return _SH._Vec_int_3_all(alpha)

class _DataType_Vec_int_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_int_3_generic_type
    channels = _SH._DataType_Vec_int_3_channels
    fmt = _SH._DataType_Vec_int_3_fmt

    def __init__(self):
        _SH._DataType_Vec_int_3_swiginit(self, _SH.new__DataType_Vec_int_3())
    __swig_destroy__ = _SH.delete__DataType_Vec_int_3

# Register _DataType_Vec_int_3 in _SH:
_SH._DataType_Vec_int_3_swigregister(_DataType_Vec_int_3)


Vec3i = _Vec_int_3
DataType_Vec3i = _DataType_Vec_int_3

class _Matx_int_4_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_int_4_1_rows
    cols = _SH._Matx_int_4_1_cols
    channels = _SH._Matx_int_4_1_channels
    shortdim = _SH._Matx_int_4_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_int_4_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_int_4_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_int_4_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_int_4_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_int_4_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_int_4_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_int_4_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_int_4_1_ddot(self, v)

    def t(self):
        return _SH._Matx_int_4_1_t(self)

    def mul(self, a):
        return _SH._Matx_int_4_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_int_4_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_int_4_1___call__(self, i, j)
    val = property(_SH._Matx_int_4_1_val_get, _SH._Matx_int_4_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_int_4_1_swiginit(self, _SH.new__Matx_int_4_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_int_4_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_int_4_1

# Register _Matx_int_4_1 in _SH:
_SH._Matx_int_4_1_swigregister(_Matx_int_4_1)

def _Matx_int_4_1_all(alpha):
    return _SH._Matx_int_4_1_all(alpha)

def _Matx_int_4_1_zeros():
    return _SH._Matx_int_4_1_zeros()

def _Matx_int_4_1_ones():
    return _SH._Matx_int_4_1_ones()

def _Matx_int_4_1_eye():
    return _SH._Matx_int_4_1_eye()

def _Matx_int_4_1_randu(a, b):
    return _SH._Matx_int_4_1_randu(a, b)

def _Matx_int_4_1_randn(a, b):
    return _SH._Matx_int_4_1_randn(a, b)


Matx41i = _Matx_int_4_1

class _Vec_int_4(_Matx_int_4_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_int_4_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_int_4_all(alpha)

    def mul(self, v):
        return _SH._Vec_int_4_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_int_4___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_int_4_swiginit(self, _SH.new__Vec_int_4(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_int_4___str__(self)
    __swig_destroy__ = _SH.delete__Vec_int_4

# Register _Vec_int_4 in _SH:
_SH._Vec_int_4_swigregister(_Vec_int_4)

def _Vec_int_4_all(alpha):
    return _SH._Vec_int_4_all(alpha)

class _DataType_Vec_int_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_int_4_generic_type
    channels = _SH._DataType_Vec_int_4_channels
    fmt = _SH._DataType_Vec_int_4_fmt

    def __init__(self):
        _SH._DataType_Vec_int_4_swiginit(self, _SH.new__DataType_Vec_int_4())
    __swig_destroy__ = _SH.delete__DataType_Vec_int_4

# Register _DataType_Vec_int_4 in _SH:
_SH._DataType_Vec_int_4_swigregister(_DataType_Vec_int_4)


Vec4i = _Vec_int_4
DataType_Vec4i = _DataType_Vec_int_4

class _Matx_int_6_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_int_6_1_rows
    cols = _SH._Matx_int_6_1_cols
    channels = _SH._Matx_int_6_1_channels
    shortdim = _SH._Matx_int_6_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_int_6_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_int_6_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_int_6_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_int_6_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_int_6_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_int_6_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_int_6_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_int_6_1_ddot(self, v)

    def t(self):
        return _SH._Matx_int_6_1_t(self)

    def mul(self, a):
        return _SH._Matx_int_6_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_int_6_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_int_6_1___call__(self, i, j)
    val = property(_SH._Matx_int_6_1_val_get, _SH._Matx_int_6_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_int_6_1_swiginit(self, _SH.new__Matx_int_6_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_int_6_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_int_6_1

# Register _Matx_int_6_1 in _SH:
_SH._Matx_int_6_1_swigregister(_Matx_int_6_1)

def _Matx_int_6_1_all(alpha):
    return _SH._Matx_int_6_1_all(alpha)

def _Matx_int_6_1_zeros():
    return _SH._Matx_int_6_1_zeros()

def _Matx_int_6_1_ones():
    return _SH._Matx_int_6_1_ones()

def _Matx_int_6_1_eye():
    return _SH._Matx_int_6_1_eye()

def _Matx_int_6_1_randu(a, b):
    return _SH._Matx_int_6_1_randu(a, b)

def _Matx_int_6_1_randn(a, b):
    return _SH._Matx_int_6_1_randn(a, b)


Matx61i = _Matx_int_6_1

class _Vec_int_6(_Matx_int_6_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_int_6_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_int_6_all(alpha)

    def mul(self, v):
        return _SH._Vec_int_6_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_int_6___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_int_6_swiginit(self, _SH.new__Vec_int_6(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_int_6___str__(self)
    __swig_destroy__ = _SH.delete__Vec_int_6

# Register _Vec_int_6 in _SH:
_SH._Vec_int_6_swigregister(_Vec_int_6)

def _Vec_int_6_all(alpha):
    return _SH._Vec_int_6_all(alpha)

class _DataType_Vec_int_6(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_int_6_generic_type
    channels = _SH._DataType_Vec_int_6_channels
    fmt = _SH._DataType_Vec_int_6_fmt

    def __init__(self):
        _SH._DataType_Vec_int_6_swiginit(self, _SH.new__DataType_Vec_int_6())
    __swig_destroy__ = _SH.delete__DataType_Vec_int_6

# Register _DataType_Vec_int_6 in _SH:
_SH._DataType_Vec_int_6_swigregister(_DataType_Vec_int_6)


Vec6i = _Vec_int_6
DataType_Vec6i = _DataType_Vec_int_6

class _Matx_int_8_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_int_8_1_rows
    cols = _SH._Matx_int_8_1_cols
    channels = _SH._Matx_int_8_1_channels
    shortdim = _SH._Matx_int_8_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_int_8_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_int_8_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_int_8_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_int_8_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_int_8_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_int_8_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_int_8_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_int_8_1_ddot(self, v)

    def t(self):
        return _SH._Matx_int_8_1_t(self)

    def mul(self, a):
        return _SH._Matx_int_8_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_int_8_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_int_8_1___call__(self, i, j)
    val = property(_SH._Matx_int_8_1_val_get, _SH._Matx_int_8_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_int_8_1_swiginit(self, _SH.new__Matx_int_8_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_int_8_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_int_8_1

# Register _Matx_int_8_1 in _SH:
_SH._Matx_int_8_1_swigregister(_Matx_int_8_1)

def _Matx_int_8_1_all(alpha):
    return _SH._Matx_int_8_1_all(alpha)

def _Matx_int_8_1_zeros():
    return _SH._Matx_int_8_1_zeros()

def _Matx_int_8_1_ones():
    return _SH._Matx_int_8_1_ones()

def _Matx_int_8_1_eye():
    return _SH._Matx_int_8_1_eye()

def _Matx_int_8_1_randu(a, b):
    return _SH._Matx_int_8_1_randu(a, b)

def _Matx_int_8_1_randn(a, b):
    return _SH._Matx_int_8_1_randn(a, b)


Matx81i = _Matx_int_8_1

class _Vec_int_8(_Matx_int_8_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_int_8_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_int_8_all(alpha)

    def mul(self, v):
        return _SH._Vec_int_8_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_int_8___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_int_8_swiginit(self, _SH.new__Vec_int_8(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_int_8___str__(self)
    __swig_destroy__ = _SH.delete__Vec_int_8

# Register _Vec_int_8 in _SH:
_SH._Vec_int_8_swigregister(_Vec_int_8)

def _Vec_int_8_all(alpha):
    return _SH._Vec_int_8_all(alpha)

class _DataType_Vec_int_8(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_int_8_generic_type
    channels = _SH._DataType_Vec_int_8_channels
    fmt = _SH._DataType_Vec_int_8_fmt

    def __init__(self):
        _SH._DataType_Vec_int_8_swiginit(self, _SH.new__DataType_Vec_int_8())
    __swig_destroy__ = _SH.delete__DataType_Vec_int_8

# Register _DataType_Vec_int_8 in _SH:
_SH._DataType_Vec_int_8_swigregister(_DataType_Vec_int_8)


Vec8i = _Vec_int_8
DataType_Vec8i = _DataType_Vec_int_8

class _cv_numpy_sizeof_float(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_float_value

    def __init__(self):
        _SH._cv_numpy_sizeof_float_swiginit(self, _SH.new__cv_numpy_sizeof_float())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_float

# Register _cv_numpy_sizeof_float in _SH:
_SH._cv_numpy_sizeof_float_swigregister(_cv_numpy_sizeof_float)


if _cv_numpy_sizeof_float.value == 1:
    _cv_numpy_typestr_map["float"] = "|" +"f" + "1"
else:
    _cv_numpy_typestr_map["float"] = _cv_numpy_endianess  +"f" + str(_cv_numpy_sizeof_float.value)

class floatArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _SH.floatArray_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _SH.floatArray___nonzero__(self)

    def __bool__(self):
        return _SH.floatArray___bool__(self)

    def __len__(self):
        return _SH.floatArray___len__(self)

    def __getslice__(self, i, j):
        return _SH.floatArray___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _SH.floatArray___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _SH.floatArray___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _SH.floatArray___delitem__(self, *args)

    def __getitem__(self, *args):
        return _SH.floatArray___getitem__(self, *args)

    def __setitem__(self, *args):
        return _SH.floatArray___setitem__(self, *args)

    def pop(self):
        return _SH.floatArray_pop(self)

    def append(self, x):
        return _SH.floatArray_append(self, x)

    def empty(self):
        return _SH.floatArray_empty(self)

    def size(self):
        return _SH.floatArray_size(self)

    def swap(self, v):
        return _SH.floatArray_swap(self, v)

    def begin(self):
        return _SH.floatArray_begin(self)

    def end(self):
        return _SH.floatArray_end(self)

    def rbegin(self):
        return _SH.floatArray_rbegin(self)

    def rend(self):
        return _SH.floatArray_rend(self)

    def clear(self):
        return _SH.floatArray_clear(self)

    def get_allocator(self):
        return _SH.floatArray_get_allocator(self)

    def pop_back(self):
        return _SH.floatArray_pop_back(self)

    def erase(self, *args):
        return _SH.floatArray_erase(self, *args)

    def __init__(self, *args):
        _SH.floatArray_swiginit(self, _SH.new_floatArray(*args))

    def push_back(self, x):
        return _SH.floatArray_push_back(self, x)

    def front(self):
        return _SH.floatArray_front(self)

    def back(self):
        return _SH.floatArray_back(self)

    def assign(self, n, x):
        return _SH.floatArray_assign(self, n, x)

    def resize(self, *args):
        return _SH.floatArray_resize(self, *args)

    def insert(self, *args):
        return _SH.floatArray_insert(self, *args)

    def reserve(self, n):
        return _SH.floatArray_reserve(self, n)

    def capacity(self):
        return _SH.floatArray_capacity(self)
    __swig_destroy__ = _SH.delete_floatArray

# Register floatArray in _SH:
_SH.floatArray_swigregister(floatArray)


_array_map["float"] =floatArray

class _Matx_float_2_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_2_1_rows
    cols = _SH._Matx_float_2_1_cols
    channels = _SH._Matx_float_2_1_channels
    shortdim = _SH._Matx_float_2_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_2_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_2_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_2_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_2_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_2_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_2_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_2_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_2_1_ddot(self, v)

    def t(self):
        return _SH._Matx_float_2_1_t(self)

    def mul(self, a):
        return _SH._Matx_float_2_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_2_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_2_1___call__(self, i, j)
    val = property(_SH._Matx_float_2_1_val_get, _SH._Matx_float_2_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_2_1_swiginit(self, _SH.new__Matx_float_2_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_2_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_2_1

# Register _Matx_float_2_1 in _SH:
_SH._Matx_float_2_1_swigregister(_Matx_float_2_1)

def _Matx_float_2_1_all(alpha):
    return _SH._Matx_float_2_1_all(alpha)

def _Matx_float_2_1_zeros():
    return _SH._Matx_float_2_1_zeros()

def _Matx_float_2_1_ones():
    return _SH._Matx_float_2_1_ones()

def _Matx_float_2_1_eye():
    return _SH._Matx_float_2_1_eye()

def _Matx_float_2_1_randu(a, b):
    return _SH._Matx_float_2_1_randu(a, b)

def _Matx_float_2_1_randn(a, b):
    return _SH._Matx_float_2_1_randn(a, b)


Matx21f = _Matx_float_2_1

class _Vec_float_2(_Matx_float_2_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_float_2_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_float_2_all(alpha)

    def mul(self, v):
        return _SH._Vec_float_2_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_float_2___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_float_2_swiginit(self, _SH.new__Vec_float_2(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_float_2___str__(self)
    __swig_destroy__ = _SH.delete__Vec_float_2

# Register _Vec_float_2 in _SH:
_SH._Vec_float_2_swigregister(_Vec_float_2)

def _Vec_float_2_all(alpha):
    return _SH._Vec_float_2_all(alpha)

class _DataType_Vec_float_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_float_2_generic_type
    channels = _SH._DataType_Vec_float_2_channels
    fmt = _SH._DataType_Vec_float_2_fmt

    def __init__(self):
        _SH._DataType_Vec_float_2_swiginit(self, _SH.new__DataType_Vec_float_2())
    __swig_destroy__ = _SH.delete__DataType_Vec_float_2

# Register _DataType_Vec_float_2 in _SH:
_SH._DataType_Vec_float_2_swigregister(_DataType_Vec_float_2)


Vec2f = _Vec_float_2
DataType_Vec2f = _DataType_Vec_float_2

class _Matx_float_3_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_3_1_rows
    cols = _SH._Matx_float_3_1_cols
    channels = _SH._Matx_float_3_1_channels
    shortdim = _SH._Matx_float_3_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_3_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_3_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_3_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_3_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_3_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_3_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_3_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_3_1_ddot(self, v)

    def t(self):
        return _SH._Matx_float_3_1_t(self)

    def mul(self, a):
        return _SH._Matx_float_3_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_3_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_3_1___call__(self, i, j)
    val = property(_SH._Matx_float_3_1_val_get, _SH._Matx_float_3_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_3_1_swiginit(self, _SH.new__Matx_float_3_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_3_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_3_1

# Register _Matx_float_3_1 in _SH:
_SH._Matx_float_3_1_swigregister(_Matx_float_3_1)

def _Matx_float_3_1_all(alpha):
    return _SH._Matx_float_3_1_all(alpha)

def _Matx_float_3_1_zeros():
    return _SH._Matx_float_3_1_zeros()

def _Matx_float_3_1_ones():
    return _SH._Matx_float_3_1_ones()

def _Matx_float_3_1_eye():
    return _SH._Matx_float_3_1_eye()

def _Matx_float_3_1_randu(a, b):
    return _SH._Matx_float_3_1_randu(a, b)

def _Matx_float_3_1_randn(a, b):
    return _SH._Matx_float_3_1_randn(a, b)


Matx31f = _Matx_float_3_1

class _Vec_float_3(_Matx_float_3_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_float_3_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_float_3_all(alpha)

    def mul(self, v):
        return _SH._Vec_float_3_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_float_3___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_float_3_swiginit(self, _SH.new__Vec_float_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_float_3___str__(self)
    __swig_destroy__ = _SH.delete__Vec_float_3

# Register _Vec_float_3 in _SH:
_SH._Vec_float_3_swigregister(_Vec_float_3)

def _Vec_float_3_all(alpha):
    return _SH._Vec_float_3_all(alpha)

class _DataType_Vec_float_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_float_3_generic_type
    channels = _SH._DataType_Vec_float_3_channels
    fmt = _SH._DataType_Vec_float_3_fmt

    def __init__(self):
        _SH._DataType_Vec_float_3_swiginit(self, _SH.new__DataType_Vec_float_3())
    __swig_destroy__ = _SH.delete__DataType_Vec_float_3

# Register _DataType_Vec_float_3 in _SH:
_SH._DataType_Vec_float_3_swigregister(_DataType_Vec_float_3)


Vec3f = _Vec_float_3
DataType_Vec3f = _DataType_Vec_float_3

class _Matx_float_4_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_4_1_rows
    cols = _SH._Matx_float_4_1_cols
    channels = _SH._Matx_float_4_1_channels
    shortdim = _SH._Matx_float_4_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_4_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_4_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_4_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_4_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_4_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_4_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_4_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_4_1_ddot(self, v)

    def t(self):
        return _SH._Matx_float_4_1_t(self)

    def mul(self, a):
        return _SH._Matx_float_4_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_4_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_4_1___call__(self, i, j)
    val = property(_SH._Matx_float_4_1_val_get, _SH._Matx_float_4_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_4_1_swiginit(self, _SH.new__Matx_float_4_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_4_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_4_1

# Register _Matx_float_4_1 in _SH:
_SH._Matx_float_4_1_swigregister(_Matx_float_4_1)

def _Matx_float_4_1_all(alpha):
    return _SH._Matx_float_4_1_all(alpha)

def _Matx_float_4_1_zeros():
    return _SH._Matx_float_4_1_zeros()

def _Matx_float_4_1_ones():
    return _SH._Matx_float_4_1_ones()

def _Matx_float_4_1_eye():
    return _SH._Matx_float_4_1_eye()

def _Matx_float_4_1_randu(a, b):
    return _SH._Matx_float_4_1_randu(a, b)

def _Matx_float_4_1_randn(a, b):
    return _SH._Matx_float_4_1_randn(a, b)


Matx41f = _Matx_float_4_1

class _Vec_float_4(_Matx_float_4_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_float_4_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_float_4_all(alpha)

    def mul(self, v):
        return _SH._Vec_float_4_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_float_4___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_float_4_swiginit(self, _SH.new__Vec_float_4(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_float_4___str__(self)
    __swig_destroy__ = _SH.delete__Vec_float_4

# Register _Vec_float_4 in _SH:
_SH._Vec_float_4_swigregister(_Vec_float_4)

def _Vec_float_4_all(alpha):
    return _SH._Vec_float_4_all(alpha)

class _DataType_Vec_float_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_float_4_generic_type
    channels = _SH._DataType_Vec_float_4_channels
    fmt = _SH._DataType_Vec_float_4_fmt

    def __init__(self):
        _SH._DataType_Vec_float_4_swiginit(self, _SH.new__DataType_Vec_float_4())
    __swig_destroy__ = _SH.delete__DataType_Vec_float_4

# Register _DataType_Vec_float_4 in _SH:
_SH._DataType_Vec_float_4_swigregister(_DataType_Vec_float_4)


Vec4f = _Vec_float_4
DataType_Vec4f = _DataType_Vec_float_4

class _Matx_float_6_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_6_1_rows
    cols = _SH._Matx_float_6_1_cols
    channels = _SH._Matx_float_6_1_channels
    shortdim = _SH._Matx_float_6_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_6_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_6_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_6_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_6_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_6_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_6_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_6_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_6_1_ddot(self, v)

    def t(self):
        return _SH._Matx_float_6_1_t(self)

    def mul(self, a):
        return _SH._Matx_float_6_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_6_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_6_1___call__(self, i, j)
    val = property(_SH._Matx_float_6_1_val_get, _SH._Matx_float_6_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_6_1_swiginit(self, _SH.new__Matx_float_6_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_6_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_6_1

# Register _Matx_float_6_1 in _SH:
_SH._Matx_float_6_1_swigregister(_Matx_float_6_1)

def _Matx_float_6_1_all(alpha):
    return _SH._Matx_float_6_1_all(alpha)

def _Matx_float_6_1_zeros():
    return _SH._Matx_float_6_1_zeros()

def _Matx_float_6_1_ones():
    return _SH._Matx_float_6_1_ones()

def _Matx_float_6_1_eye():
    return _SH._Matx_float_6_1_eye()

def _Matx_float_6_1_randu(a, b):
    return _SH._Matx_float_6_1_randu(a, b)

def _Matx_float_6_1_randn(a, b):
    return _SH._Matx_float_6_1_randn(a, b)


Matx61f = _Matx_float_6_1

class _Vec_float_6(_Matx_float_6_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_float_6_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_float_6_all(alpha)

    def mul(self, v):
        return _SH._Vec_float_6_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_float_6___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_float_6_swiginit(self, _SH.new__Vec_float_6(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_float_6___str__(self)
    __swig_destroy__ = _SH.delete__Vec_float_6

# Register _Vec_float_6 in _SH:
_SH._Vec_float_6_swigregister(_Vec_float_6)

def _Vec_float_6_all(alpha):
    return _SH._Vec_float_6_all(alpha)

class _DataType_Vec_float_6(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_float_6_generic_type
    channels = _SH._DataType_Vec_float_6_channels
    fmt = _SH._DataType_Vec_float_6_fmt

    def __init__(self):
        _SH._DataType_Vec_float_6_swiginit(self, _SH.new__DataType_Vec_float_6())
    __swig_destroy__ = _SH.delete__DataType_Vec_float_6

# Register _DataType_Vec_float_6 in _SH:
_SH._DataType_Vec_float_6_swigregister(_DataType_Vec_float_6)


Vec6f = _Vec_float_6
DataType_Vec6f = _DataType_Vec_float_6

class _cv_numpy_sizeof_double(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_double_value

    def __init__(self):
        _SH._cv_numpy_sizeof_double_swiginit(self, _SH.new__cv_numpy_sizeof_double())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_double

# Register _cv_numpy_sizeof_double in _SH:
_SH._cv_numpy_sizeof_double_swigregister(_cv_numpy_sizeof_double)


if _cv_numpy_sizeof_double.value == 1:
    _cv_numpy_typestr_map["double"] = "|" +"f" + "1"
else:
    _cv_numpy_typestr_map["double"] = _cv_numpy_endianess  +"f" + str(_cv_numpy_sizeof_double.value)

class doubleArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _SH.doubleArray_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _SH.doubleArray___nonzero__(self)

    def __bool__(self):
        return _SH.doubleArray___bool__(self)

    def __len__(self):
        return _SH.doubleArray___len__(self)

    def __getslice__(self, i, j):
        return _SH.doubleArray___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _SH.doubleArray___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _SH.doubleArray___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _SH.doubleArray___delitem__(self, *args)

    def __getitem__(self, *args):
        return _SH.doubleArray___getitem__(self, *args)

    def __setitem__(self, *args):
        return _SH.doubleArray___setitem__(self, *args)

    def pop(self):
        return _SH.doubleArray_pop(self)

    def append(self, x):
        return _SH.doubleArray_append(self, x)

    def empty(self):
        return _SH.doubleArray_empty(self)

    def size(self):
        return _SH.doubleArray_size(self)

    def swap(self, v):
        return _SH.doubleArray_swap(self, v)

    def begin(self):
        return _SH.doubleArray_begin(self)

    def end(self):
        return _SH.doubleArray_end(self)

    def rbegin(self):
        return _SH.doubleArray_rbegin(self)

    def rend(self):
        return _SH.doubleArray_rend(self)

    def clear(self):
        return _SH.doubleArray_clear(self)

    def get_allocator(self):
        return _SH.doubleArray_get_allocator(self)

    def pop_back(self):
        return _SH.doubleArray_pop_back(self)

    def erase(self, *args):
        return _SH.doubleArray_erase(self, *args)

    def __init__(self, *args):
        _SH.doubleArray_swiginit(self, _SH.new_doubleArray(*args))

    def push_back(self, x):
        return _SH.doubleArray_push_back(self, x)

    def front(self):
        return _SH.doubleArray_front(self)

    def back(self):
        return _SH.doubleArray_back(self)

    def assign(self, n, x):
        return _SH.doubleArray_assign(self, n, x)

    def resize(self, *args):
        return _SH.doubleArray_resize(self, *args)

    def insert(self, *args):
        return _SH.doubleArray_insert(self, *args)

    def reserve(self, n):
        return _SH.doubleArray_reserve(self, n)

    def capacity(self):
        return _SH.doubleArray_capacity(self)
    __swig_destroy__ = _SH.delete_doubleArray

# Register doubleArray in _SH:
_SH.doubleArray_swigregister(doubleArray)


_array_map["double"] =doubleArray

class _Matx_double_2_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_2_1_rows
    cols = _SH._Matx_double_2_1_cols
    channels = _SH._Matx_double_2_1_channels
    shortdim = _SH._Matx_double_2_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_2_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_2_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_2_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_2_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_2_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_2_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_2_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_2_1_ddot(self, v)

    def t(self):
        return _SH._Matx_double_2_1_t(self)

    def mul(self, a):
        return _SH._Matx_double_2_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_2_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_2_1___call__(self, i, j)
    val = property(_SH._Matx_double_2_1_val_get, _SH._Matx_double_2_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_2_1_swiginit(self, _SH.new__Matx_double_2_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_2_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_2_1

# Register _Matx_double_2_1 in _SH:
_SH._Matx_double_2_1_swigregister(_Matx_double_2_1)

def _Matx_double_2_1_all(alpha):
    return _SH._Matx_double_2_1_all(alpha)

def _Matx_double_2_1_zeros():
    return _SH._Matx_double_2_1_zeros()

def _Matx_double_2_1_ones():
    return _SH._Matx_double_2_1_ones()

def _Matx_double_2_1_eye():
    return _SH._Matx_double_2_1_eye()

def _Matx_double_2_1_randu(a, b):
    return _SH._Matx_double_2_1_randu(a, b)

def _Matx_double_2_1_randn(a, b):
    return _SH._Matx_double_2_1_randn(a, b)


Matx21d = _Matx_double_2_1

class _Vec_double_2(_Matx_double_2_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_double_2_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_double_2_all(alpha)

    def mul(self, v):
        return _SH._Vec_double_2_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_double_2___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_double_2_swiginit(self, _SH.new__Vec_double_2(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_double_2___str__(self)
    __swig_destroy__ = _SH.delete__Vec_double_2

# Register _Vec_double_2 in _SH:
_SH._Vec_double_2_swigregister(_Vec_double_2)

def _Vec_double_2_all(alpha):
    return _SH._Vec_double_2_all(alpha)

class _DataType_Vec_double_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_double_2_generic_type
    channels = _SH._DataType_Vec_double_2_channels
    fmt = _SH._DataType_Vec_double_2_fmt

    def __init__(self):
        _SH._DataType_Vec_double_2_swiginit(self, _SH.new__DataType_Vec_double_2())
    __swig_destroy__ = _SH.delete__DataType_Vec_double_2

# Register _DataType_Vec_double_2 in _SH:
_SH._DataType_Vec_double_2_swigregister(_DataType_Vec_double_2)


Vec2d = _Vec_double_2
DataType_Vec2d = _DataType_Vec_double_2

class _Matx_double_3_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_3_1_rows
    cols = _SH._Matx_double_3_1_cols
    channels = _SH._Matx_double_3_1_channels
    shortdim = _SH._Matx_double_3_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_3_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_3_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_3_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_3_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_3_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_3_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_3_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_3_1_ddot(self, v)

    def t(self):
        return _SH._Matx_double_3_1_t(self)

    def mul(self, a):
        return _SH._Matx_double_3_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_3_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_3_1___call__(self, i, j)
    val = property(_SH._Matx_double_3_1_val_get, _SH._Matx_double_3_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_3_1_swiginit(self, _SH.new__Matx_double_3_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_3_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_3_1

# Register _Matx_double_3_1 in _SH:
_SH._Matx_double_3_1_swigregister(_Matx_double_3_1)

def _Matx_double_3_1_all(alpha):
    return _SH._Matx_double_3_1_all(alpha)

def _Matx_double_3_1_zeros():
    return _SH._Matx_double_3_1_zeros()

def _Matx_double_3_1_ones():
    return _SH._Matx_double_3_1_ones()

def _Matx_double_3_1_eye():
    return _SH._Matx_double_3_1_eye()

def _Matx_double_3_1_randu(a, b):
    return _SH._Matx_double_3_1_randu(a, b)

def _Matx_double_3_1_randn(a, b):
    return _SH._Matx_double_3_1_randn(a, b)


Matx31d = _Matx_double_3_1

class _Vec_double_3(_Matx_double_3_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_double_3_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_double_3_all(alpha)

    def mul(self, v):
        return _SH._Vec_double_3_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_double_3___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_double_3_swiginit(self, _SH.new__Vec_double_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_double_3___str__(self)
    __swig_destroy__ = _SH.delete__Vec_double_3

# Register _Vec_double_3 in _SH:
_SH._Vec_double_3_swigregister(_Vec_double_3)

def _Vec_double_3_all(alpha):
    return _SH._Vec_double_3_all(alpha)

class _DataType_Vec_double_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_double_3_generic_type
    channels = _SH._DataType_Vec_double_3_channels
    fmt = _SH._DataType_Vec_double_3_fmt

    def __init__(self):
        _SH._DataType_Vec_double_3_swiginit(self, _SH.new__DataType_Vec_double_3())
    __swig_destroy__ = _SH.delete__DataType_Vec_double_3

# Register _DataType_Vec_double_3 in _SH:
_SH._DataType_Vec_double_3_swigregister(_DataType_Vec_double_3)


Vec3d = _Vec_double_3
DataType_Vec3d = _DataType_Vec_double_3

class _Matx_double_4_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_4_1_rows
    cols = _SH._Matx_double_4_1_cols
    channels = _SH._Matx_double_4_1_channels
    shortdim = _SH._Matx_double_4_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_4_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_4_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_4_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_4_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_4_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_4_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_4_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_4_1_ddot(self, v)

    def t(self):
        return _SH._Matx_double_4_1_t(self)

    def mul(self, a):
        return _SH._Matx_double_4_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_4_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_4_1___call__(self, i, j)
    val = property(_SH._Matx_double_4_1_val_get, _SH._Matx_double_4_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_4_1_swiginit(self, _SH.new__Matx_double_4_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_4_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_4_1

# Register _Matx_double_4_1 in _SH:
_SH._Matx_double_4_1_swigregister(_Matx_double_4_1)

def _Matx_double_4_1_all(alpha):
    return _SH._Matx_double_4_1_all(alpha)

def _Matx_double_4_1_zeros():
    return _SH._Matx_double_4_1_zeros()

def _Matx_double_4_1_ones():
    return _SH._Matx_double_4_1_ones()

def _Matx_double_4_1_eye():
    return _SH._Matx_double_4_1_eye()

def _Matx_double_4_1_randu(a, b):
    return _SH._Matx_double_4_1_randu(a, b)

def _Matx_double_4_1_randn(a, b):
    return _SH._Matx_double_4_1_randn(a, b)


Matx41d = _Matx_double_4_1

class _Vec_double_4(_Matx_double_4_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_double_4_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_double_4_all(alpha)

    def mul(self, v):
        return _SH._Vec_double_4_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_double_4___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_double_4_swiginit(self, _SH.new__Vec_double_4(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_double_4___str__(self)
    __swig_destroy__ = _SH.delete__Vec_double_4

# Register _Vec_double_4 in _SH:
_SH._Vec_double_4_swigregister(_Vec_double_4)

def _Vec_double_4_all(alpha):
    return _SH._Vec_double_4_all(alpha)

class _DataType_Vec_double_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_double_4_generic_type
    channels = _SH._DataType_Vec_double_4_channels
    fmt = _SH._DataType_Vec_double_4_fmt

    def __init__(self):
        _SH._DataType_Vec_double_4_swiginit(self, _SH.new__DataType_Vec_double_4())
    __swig_destroy__ = _SH.delete__DataType_Vec_double_4

# Register _DataType_Vec_double_4 in _SH:
_SH._DataType_Vec_double_4_swigregister(_DataType_Vec_double_4)


Vec4d = _Vec_double_4
DataType_Vec4d = _DataType_Vec_double_4

class _Matx_double_6_1(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_6_1_rows
    cols = _SH._Matx_double_6_1_cols
    channels = _SH._Matx_double_6_1_channels
    shortdim = _SH._Matx_double_6_1_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_6_1_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_6_1_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_6_1_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_6_1_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_6_1_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_6_1_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_6_1_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_6_1_ddot(self, v)

    def t(self):
        return _SH._Matx_double_6_1_t(self)

    def mul(self, a):
        return _SH._Matx_double_6_1_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_6_1_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_6_1___call__(self, i, j)
    val = property(_SH._Matx_double_6_1_val_get, _SH._Matx_double_6_1_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_6_1_swiginit(self, _SH.new__Matx_double_6_1(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_6_1___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_6_1

# Register _Matx_double_6_1 in _SH:
_SH._Matx_double_6_1_swigregister(_Matx_double_6_1)

def _Matx_double_6_1_all(alpha):
    return _SH._Matx_double_6_1_all(alpha)

def _Matx_double_6_1_zeros():
    return _SH._Matx_double_6_1_zeros()

def _Matx_double_6_1_ones():
    return _SH._Matx_double_6_1_ones()

def _Matx_double_6_1_eye():
    return _SH._Matx_double_6_1_eye()

def _Matx_double_6_1_randu(a, b):
    return _SH._Matx_double_6_1_randu(a, b)

def _Matx_double_6_1_randn(a, b):
    return _SH._Matx_double_6_1_randn(a, b)


Matx61d = _Matx_double_6_1

class _Vec_double_6(_Matx_double_6_1):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    channels = _SH._Vec_double_6_channels

    @staticmethod
    def all(alpha):
        return _SH._Vec_double_6_all(alpha)

    def mul(self, v):
        return _SH._Vec_double_6_mul(self, v)

    def __call__(self, i):
        return _SH._Vec_double_6___call__(self, i)

    import re
    _re_pattern = re.compile("^_Vec_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))

        array = _array_map[value_type](rows)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Vec_double_6_swiginit(self, _SH.new__Vec_double_6(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            return {"shape": (rows, 1),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)

    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))

        if not isinstance(key, int):
            raise TypeError

        if key >= rows:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Vec_double_6___str__(self)
    __swig_destroy__ = _SH.delete__Vec_double_6

# Register _Vec_double_6 in _SH:
_SH._Vec_double_6_swigregister(_Vec_double_6)

def _Vec_double_6_all(alpha):
    return _SH._Vec_double_6_all(alpha)

class _DataType_Vec_double_6(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    generic_type = _SH._DataType_Vec_double_6_generic_type
    channels = _SH._DataType_Vec_double_6_channels
    fmt = _SH._DataType_Vec_double_6_fmt

    def __init__(self):
        _SH._DataType_Vec_double_6_swiginit(self, _SH.new__DataType_Vec_double_6())
    __swig_destroy__ = _SH.delete__DataType_Vec_double_6

# Register _DataType_Vec_double_6 in _SH:
_SH._DataType_Vec_double_6_swigregister(_DataType_Vec_double_6)


Vec6d = _Vec_double_6
DataType_Vec6d = _DataType_Vec_double_6

class _mat__np_array_constructor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _SH._mat__np_array_constructor_swiginit(self, _SH.new__mat__np_array_constructor())
    __swig_destroy__ = _SH.delete__mat__np_array_constructor

# Register _mat__np_array_constructor in _SH:
_SH._mat__np_array_constructor_swigregister(_mat__np_array_constructor)


def _depthToDtype(depth):
    return _SH._depthToDtype(depth)

def _toCvType(dtype, nChannel):
    return _SH._toCvType(dtype, nChannel)
class _cv_numpy_sizeof_uchar(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_uchar_value

    def __init__(self):
        _SH._cv_numpy_sizeof_uchar_swiginit(self, _SH.new__cv_numpy_sizeof_uchar())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_uchar

# Register _cv_numpy_sizeof_uchar in _SH:
_SH._cv_numpy_sizeof_uchar_swigregister(_cv_numpy_sizeof_uchar)


if _cv_numpy_sizeof_uchar.value == 1:
    _cv_numpy_typestr_map["uchar"] = "|" +"u" + "1"
else:
    _cv_numpy_typestr_map["uchar"] = _cv_numpy_endianess  +"u" + str(_cv_numpy_sizeof_uchar.value)

class _Mat__uchar(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__uchar_create(self, *args)

    def cross(self, m):
        return _SH._Mat__uchar_cross(self, m)

    def row(self, y):
        return _SH._Mat__uchar_row(self, y)

    def col(self, x):
        return _SH._Mat__uchar_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__uchar_diag(self, d)

    def clone(self):
        return _SH._Mat__uchar_clone(self)

    def elemSize(self):
        return _SH._Mat__uchar_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__uchar_elemSize1(self)

    def type(self):
        return _SH._Mat__uchar_type(self)

    def depth(self):
        return _SH._Mat__uchar_depth(self)

    def channels(self):
        return _SH._Mat__uchar_channels(self)

    def step1(self, i=0):
        return _SH._Mat__uchar_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__uchar_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__uchar_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__uchar___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__uchar_swiginit(self, _SH.new__Mat__uchar(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__uchar___str__(self)
    __swig_destroy__ = _SH.delete__Mat__uchar

# Register _Mat__uchar in _SH:
_SH._Mat__uchar_swigregister(_Mat__uchar)


Mat1b = _Mat__uchar

class _cv_numpy_sizeof_Vec2b(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec2b_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec2b_swiginit(self, _SH.new__cv_numpy_sizeof_Vec2b())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec2b

# Register _cv_numpy_sizeof_Vec2b in _SH:
_SH._cv_numpy_sizeof_Vec2b_swigregister(_cv_numpy_sizeof_Vec2b)


if _cv_numpy_sizeof_Vec2b.value == 1:
    _cv_numpy_typestr_map["Vec2b"] = "|" +"u" + "1"
else:
    _cv_numpy_typestr_map["Vec2b"] = _cv_numpy_endianess  +"u" + str(_cv_numpy_sizeof_Vec2b.value)

class _Mat__Vec2b(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec2b_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec2b_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec2b_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec2b_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec2b_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec2b_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec2b_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec2b_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec2b_type(self)

    def depth(self):
        return _SH._Mat__Vec2b_depth(self)

    def channels(self):
        return _SH._Mat__Vec2b_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec2b_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec2b_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec2b_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec2b___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec2b_swiginit(self, _SH.new__Mat__Vec2b(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec2b___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec2b

# Register _Mat__Vec2b in _SH:
_SH._Mat__Vec2b_swigregister(_Mat__Vec2b)


Mat2b = _Mat__Vec2b

class _cv_numpy_sizeof_Vec3b(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec3b_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec3b_swiginit(self, _SH.new__cv_numpy_sizeof_Vec3b())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec3b

# Register _cv_numpy_sizeof_Vec3b in _SH:
_SH._cv_numpy_sizeof_Vec3b_swigregister(_cv_numpy_sizeof_Vec3b)


if _cv_numpy_sizeof_Vec3b.value == 1:
    _cv_numpy_typestr_map["Vec3b"] = "|" +"u" + "1"
else:
    _cv_numpy_typestr_map["Vec3b"] = _cv_numpy_endianess  +"u" + str(_cv_numpy_sizeof_Vec3b.value)

class _Mat__Vec3b(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec3b_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec3b_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec3b_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec3b_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec3b_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec3b_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec3b_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec3b_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec3b_type(self)

    def depth(self):
        return _SH._Mat__Vec3b_depth(self)

    def channels(self):
        return _SH._Mat__Vec3b_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec3b_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec3b_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec3b_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec3b___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec3b_swiginit(self, _SH.new__Mat__Vec3b(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec3b___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec3b

# Register _Mat__Vec3b in _SH:
_SH._Mat__Vec3b_swigregister(_Mat__Vec3b)


Mat3b = _Mat__Vec3b

class _cv_numpy_sizeof_Vec4b(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec4b_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec4b_swiginit(self, _SH.new__cv_numpy_sizeof_Vec4b())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec4b

# Register _cv_numpy_sizeof_Vec4b in _SH:
_SH._cv_numpy_sizeof_Vec4b_swigregister(_cv_numpy_sizeof_Vec4b)


if _cv_numpy_sizeof_Vec4b.value == 1:
    _cv_numpy_typestr_map["Vec4b"] = "|" +"u" + "1"
else:
    _cv_numpy_typestr_map["Vec4b"] = _cv_numpy_endianess  +"u" + str(_cv_numpy_sizeof_Vec4b.value)

class _Mat__Vec4b(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec4b_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec4b_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec4b_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec4b_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec4b_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec4b_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec4b_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec4b_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec4b_type(self)

    def depth(self):
        return _SH._Mat__Vec4b_depth(self)

    def channels(self):
        return _SH._Mat__Vec4b_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec4b_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec4b_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec4b_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec4b___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec4b_swiginit(self, _SH.new__Mat__Vec4b(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec4b___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec4b

# Register _Mat__Vec4b in _SH:
_SH._Mat__Vec4b_swigregister(_Mat__Vec4b)


Mat4b = _Mat__Vec4b

class _Mat__short(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__short_create(self, *args)

    def cross(self, m):
        return _SH._Mat__short_cross(self, m)

    def row(self, y):
        return _SH._Mat__short_row(self, y)

    def col(self, x):
        return _SH._Mat__short_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__short_diag(self, d)

    def clone(self):
        return _SH._Mat__short_clone(self)

    def elemSize(self):
        return _SH._Mat__short_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__short_elemSize1(self)

    def type(self):
        return _SH._Mat__short_type(self)

    def depth(self):
        return _SH._Mat__short_depth(self)

    def channels(self):
        return _SH._Mat__short_channels(self)

    def step1(self, i=0):
        return _SH._Mat__short_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__short_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__short_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__short___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__short_swiginit(self, _SH.new__Mat__short(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__short___str__(self)
    __swig_destroy__ = _SH.delete__Mat__short

# Register _Mat__short in _SH:
_SH._Mat__short_swigregister(_Mat__short)


Mat1s = _Mat__short

class _cv_numpy_sizeof_Vec2s(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec2s_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec2s_swiginit(self, _SH.new__cv_numpy_sizeof_Vec2s())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec2s

# Register _cv_numpy_sizeof_Vec2s in _SH:
_SH._cv_numpy_sizeof_Vec2s_swigregister(_cv_numpy_sizeof_Vec2s)


if _cv_numpy_sizeof_Vec2s.value == 1:
    _cv_numpy_typestr_map["Vec2s"] = "|" +"i" + "1"
else:
    _cv_numpy_typestr_map["Vec2s"] = _cv_numpy_endianess  +"i" + str(_cv_numpy_sizeof_Vec2s.value)

class _Mat__Vec2s(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec2s_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec2s_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec2s_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec2s_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec2s_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec2s_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec2s_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec2s_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec2s_type(self)

    def depth(self):
        return _SH._Mat__Vec2s_depth(self)

    def channels(self):
        return _SH._Mat__Vec2s_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec2s_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec2s_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec2s_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec2s___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec2s_swiginit(self, _SH.new__Mat__Vec2s(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec2s___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec2s

# Register _Mat__Vec2s in _SH:
_SH._Mat__Vec2s_swigregister(_Mat__Vec2s)


Mat2s = _Mat__Vec2s

class _cv_numpy_sizeof_Vec3s(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec3s_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec3s_swiginit(self, _SH.new__cv_numpy_sizeof_Vec3s())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec3s

# Register _cv_numpy_sizeof_Vec3s in _SH:
_SH._cv_numpy_sizeof_Vec3s_swigregister(_cv_numpy_sizeof_Vec3s)


if _cv_numpy_sizeof_Vec3s.value == 1:
    _cv_numpy_typestr_map["Vec3s"] = "|" +"i" + "1"
else:
    _cv_numpy_typestr_map["Vec3s"] = _cv_numpy_endianess  +"i" + str(_cv_numpy_sizeof_Vec3s.value)

class _Mat__Vec3s(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec3s_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec3s_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec3s_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec3s_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec3s_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec3s_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec3s_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec3s_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec3s_type(self)

    def depth(self):
        return _SH._Mat__Vec3s_depth(self)

    def channels(self):
        return _SH._Mat__Vec3s_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec3s_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec3s_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec3s_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec3s___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec3s_swiginit(self, _SH.new__Mat__Vec3s(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec3s___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec3s

# Register _Mat__Vec3s in _SH:
_SH._Mat__Vec3s_swigregister(_Mat__Vec3s)


Mat3s = _Mat__Vec3s

class _cv_numpy_sizeof_Vec4s(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec4s_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec4s_swiginit(self, _SH.new__cv_numpy_sizeof_Vec4s())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec4s

# Register _cv_numpy_sizeof_Vec4s in _SH:
_SH._cv_numpy_sizeof_Vec4s_swigregister(_cv_numpy_sizeof_Vec4s)


if _cv_numpy_sizeof_Vec4s.value == 1:
    _cv_numpy_typestr_map["Vec4s"] = "|" +"i" + "1"
else:
    _cv_numpy_typestr_map["Vec4s"] = _cv_numpy_endianess  +"i" + str(_cv_numpy_sizeof_Vec4s.value)

class _Mat__Vec4s(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec4s_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec4s_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec4s_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec4s_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec4s_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec4s_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec4s_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec4s_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec4s_type(self)

    def depth(self):
        return _SH._Mat__Vec4s_depth(self)

    def channels(self):
        return _SH._Mat__Vec4s_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec4s_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec4s_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec4s_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec4s___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec4s_swiginit(self, _SH.new__Mat__Vec4s(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec4s___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec4s

# Register _Mat__Vec4s in _SH:
_SH._Mat__Vec4s_swigregister(_Mat__Vec4s)


Mat4s = _Mat__Vec4s

class _Mat__ushort(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__ushort_create(self, *args)

    def cross(self, m):
        return _SH._Mat__ushort_cross(self, m)

    def row(self, y):
        return _SH._Mat__ushort_row(self, y)

    def col(self, x):
        return _SH._Mat__ushort_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__ushort_diag(self, d)

    def clone(self):
        return _SH._Mat__ushort_clone(self)

    def elemSize(self):
        return _SH._Mat__ushort_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__ushort_elemSize1(self)

    def type(self):
        return _SH._Mat__ushort_type(self)

    def depth(self):
        return _SH._Mat__ushort_depth(self)

    def channels(self):
        return _SH._Mat__ushort_channels(self)

    def step1(self, i=0):
        return _SH._Mat__ushort_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__ushort_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__ushort_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__ushort___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__ushort_swiginit(self, _SH.new__Mat__ushort(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__ushort___str__(self)
    __swig_destroy__ = _SH.delete__Mat__ushort

# Register _Mat__ushort in _SH:
_SH._Mat__ushort_swigregister(_Mat__ushort)


Mat1w = _Mat__ushort

class _cv_numpy_sizeof_Vec2w(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec2w_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec2w_swiginit(self, _SH.new__cv_numpy_sizeof_Vec2w())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec2w

# Register _cv_numpy_sizeof_Vec2w in _SH:
_SH._cv_numpy_sizeof_Vec2w_swigregister(_cv_numpy_sizeof_Vec2w)


if _cv_numpy_sizeof_Vec2w.value == 1:
    _cv_numpy_typestr_map["Vec2w"] = "|" +"u" + "1"
else:
    _cv_numpy_typestr_map["Vec2w"] = _cv_numpy_endianess  +"u" + str(_cv_numpy_sizeof_Vec2w.value)

class _Mat__Vec2w(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec2w_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec2w_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec2w_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec2w_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec2w_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec2w_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec2w_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec2w_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec2w_type(self)

    def depth(self):
        return _SH._Mat__Vec2w_depth(self)

    def channels(self):
        return _SH._Mat__Vec2w_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec2w_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec2w_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec2w_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec2w___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec2w_swiginit(self, _SH.new__Mat__Vec2w(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec2w___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec2w

# Register _Mat__Vec2w in _SH:
_SH._Mat__Vec2w_swigregister(_Mat__Vec2w)


Mat2w = _Mat__Vec2w

class _cv_numpy_sizeof_Vec3w(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec3w_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec3w_swiginit(self, _SH.new__cv_numpy_sizeof_Vec3w())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec3w

# Register _cv_numpy_sizeof_Vec3w in _SH:
_SH._cv_numpy_sizeof_Vec3w_swigregister(_cv_numpy_sizeof_Vec3w)


if _cv_numpy_sizeof_Vec3w.value == 1:
    _cv_numpy_typestr_map["Vec3w"] = "|" +"u" + "1"
else:
    _cv_numpy_typestr_map["Vec3w"] = _cv_numpy_endianess  +"u" + str(_cv_numpy_sizeof_Vec3w.value)

class _Mat__Vec3w(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec3w_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec3w_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec3w_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec3w_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec3w_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec3w_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec3w_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec3w_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec3w_type(self)

    def depth(self):
        return _SH._Mat__Vec3w_depth(self)

    def channels(self):
        return _SH._Mat__Vec3w_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec3w_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec3w_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec3w_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec3w___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec3w_swiginit(self, _SH.new__Mat__Vec3w(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec3w___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec3w

# Register _Mat__Vec3w in _SH:
_SH._Mat__Vec3w_swigregister(_Mat__Vec3w)


Mat3w = _Mat__Vec3w

class _cv_numpy_sizeof_Vec4w(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec4w_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec4w_swiginit(self, _SH.new__cv_numpy_sizeof_Vec4w())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec4w

# Register _cv_numpy_sizeof_Vec4w in _SH:
_SH._cv_numpy_sizeof_Vec4w_swigregister(_cv_numpy_sizeof_Vec4w)


if _cv_numpy_sizeof_Vec4w.value == 1:
    _cv_numpy_typestr_map["Vec4w"] = "|" +"u" + "1"
else:
    _cv_numpy_typestr_map["Vec4w"] = _cv_numpy_endianess  +"u" + str(_cv_numpy_sizeof_Vec4w.value)

class _Mat__Vec4w(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec4w_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec4w_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec4w_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec4w_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec4w_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec4w_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec4w_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec4w_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec4w_type(self)

    def depth(self):
        return _SH._Mat__Vec4w_depth(self)

    def channels(self):
        return _SH._Mat__Vec4w_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec4w_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec4w_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec4w_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec4w___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec4w_swiginit(self, _SH.new__Mat__Vec4w(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec4w___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec4w

# Register _Mat__Vec4w in _SH:
_SH._Mat__Vec4w_swigregister(_Mat__Vec4w)


Mat4w = _Mat__Vec4w

class _Mat__int(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__int_create(self, *args)

    def cross(self, m):
        return _SH._Mat__int_cross(self, m)

    def row(self, y):
        return _SH._Mat__int_row(self, y)

    def col(self, x):
        return _SH._Mat__int_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__int_diag(self, d)

    def clone(self):
        return _SH._Mat__int_clone(self)

    def elemSize(self):
        return _SH._Mat__int_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__int_elemSize1(self)

    def type(self):
        return _SH._Mat__int_type(self)

    def depth(self):
        return _SH._Mat__int_depth(self)

    def channels(self):
        return _SH._Mat__int_channels(self)

    def step1(self, i=0):
        return _SH._Mat__int_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__int_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__int_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__int___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__int_swiginit(self, _SH.new__Mat__int(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__int___str__(self)
    __swig_destroy__ = _SH.delete__Mat__int

# Register _Mat__int in _SH:
_SH._Mat__int_swigregister(_Mat__int)


Mat1i = _Mat__int

class _cv_numpy_sizeof_Vec2i(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec2i_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec2i_swiginit(self, _SH.new__cv_numpy_sizeof_Vec2i())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec2i

# Register _cv_numpy_sizeof_Vec2i in _SH:
_SH._cv_numpy_sizeof_Vec2i_swigregister(_cv_numpy_sizeof_Vec2i)


if _cv_numpy_sizeof_Vec2i.value == 1:
    _cv_numpy_typestr_map["Vec2i"] = "|" +"i" + "1"
else:
    _cv_numpy_typestr_map["Vec2i"] = _cv_numpy_endianess  +"i" + str(_cv_numpy_sizeof_Vec2i.value)

class _Mat__Vec2i(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec2i_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec2i_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec2i_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec2i_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec2i_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec2i_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec2i_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec2i_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec2i_type(self)

    def depth(self):
        return _SH._Mat__Vec2i_depth(self)

    def channels(self):
        return _SH._Mat__Vec2i_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec2i_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec2i_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec2i_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec2i___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec2i_swiginit(self, _SH.new__Mat__Vec2i(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec2i___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec2i

# Register _Mat__Vec2i in _SH:
_SH._Mat__Vec2i_swigregister(_Mat__Vec2i)


Mat2i = _Mat__Vec2i

class _cv_numpy_sizeof_Vec3i(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec3i_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec3i_swiginit(self, _SH.new__cv_numpy_sizeof_Vec3i())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec3i

# Register _cv_numpy_sizeof_Vec3i in _SH:
_SH._cv_numpy_sizeof_Vec3i_swigregister(_cv_numpy_sizeof_Vec3i)


if _cv_numpy_sizeof_Vec3i.value == 1:
    _cv_numpy_typestr_map["Vec3i"] = "|" +"i" + "1"
else:
    _cv_numpy_typestr_map["Vec3i"] = _cv_numpy_endianess  +"i" + str(_cv_numpy_sizeof_Vec3i.value)

class _Mat__Vec3i(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec3i_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec3i_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec3i_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec3i_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec3i_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec3i_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec3i_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec3i_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec3i_type(self)

    def depth(self):
        return _SH._Mat__Vec3i_depth(self)

    def channels(self):
        return _SH._Mat__Vec3i_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec3i_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec3i_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec3i_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec3i___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec3i_swiginit(self, _SH.new__Mat__Vec3i(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec3i___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec3i

# Register _Mat__Vec3i in _SH:
_SH._Mat__Vec3i_swigregister(_Mat__Vec3i)


Mat3i = _Mat__Vec3i

class _cv_numpy_sizeof_Vec4i(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec4i_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec4i_swiginit(self, _SH.new__cv_numpy_sizeof_Vec4i())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec4i

# Register _cv_numpy_sizeof_Vec4i in _SH:
_SH._cv_numpy_sizeof_Vec4i_swigregister(_cv_numpy_sizeof_Vec4i)


if _cv_numpy_sizeof_Vec4i.value == 1:
    _cv_numpy_typestr_map["Vec4i"] = "|" +"i" + "1"
else:
    _cv_numpy_typestr_map["Vec4i"] = _cv_numpy_endianess  +"i" + str(_cv_numpy_sizeof_Vec4i.value)

class _Mat__Vec4i(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec4i_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec4i_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec4i_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec4i_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec4i_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec4i_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec4i_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec4i_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec4i_type(self)

    def depth(self):
        return _SH._Mat__Vec4i_depth(self)

    def channels(self):
        return _SH._Mat__Vec4i_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec4i_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec4i_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec4i_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec4i___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec4i_swiginit(self, _SH.new__Mat__Vec4i(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec4i___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec4i

# Register _Mat__Vec4i in _SH:
_SH._Mat__Vec4i_swigregister(_Mat__Vec4i)


Mat4i = _Mat__Vec4i

class _Mat__float(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__float_create(self, *args)

    def cross(self, m):
        return _SH._Mat__float_cross(self, m)

    def row(self, y):
        return _SH._Mat__float_row(self, y)

    def col(self, x):
        return _SH._Mat__float_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__float_diag(self, d)

    def clone(self):
        return _SH._Mat__float_clone(self)

    def elemSize(self):
        return _SH._Mat__float_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__float_elemSize1(self)

    def type(self):
        return _SH._Mat__float_type(self)

    def depth(self):
        return _SH._Mat__float_depth(self)

    def channels(self):
        return _SH._Mat__float_channels(self)

    def step1(self, i=0):
        return _SH._Mat__float_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__float_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__float_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__float___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__float_swiginit(self, _SH.new__Mat__float(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__float___str__(self)
    __swig_destroy__ = _SH.delete__Mat__float

# Register _Mat__float in _SH:
_SH._Mat__float_swigregister(_Mat__float)


Mat1f = _Mat__float

class _cv_numpy_sizeof_Vec2f(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec2f_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec2f_swiginit(self, _SH.new__cv_numpy_sizeof_Vec2f())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec2f

# Register _cv_numpy_sizeof_Vec2f in _SH:
_SH._cv_numpy_sizeof_Vec2f_swigregister(_cv_numpy_sizeof_Vec2f)


if _cv_numpy_sizeof_Vec2f.value == 1:
    _cv_numpy_typestr_map["Vec2f"] = "|" +"f" + "1"
else:
    _cv_numpy_typestr_map["Vec2f"] = _cv_numpy_endianess  +"f" + str(_cv_numpy_sizeof_Vec2f.value)

class _Mat__Vec2f(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec2f_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec2f_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec2f_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec2f_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec2f_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec2f_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec2f_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec2f_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec2f_type(self)

    def depth(self):
        return _SH._Mat__Vec2f_depth(self)

    def channels(self):
        return _SH._Mat__Vec2f_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec2f_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec2f_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec2f_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec2f___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec2f_swiginit(self, _SH.new__Mat__Vec2f(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec2f___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec2f

# Register _Mat__Vec2f in _SH:
_SH._Mat__Vec2f_swigregister(_Mat__Vec2f)


Mat2f = _Mat__Vec2f

class _cv_numpy_sizeof_Vec3f(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec3f_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec3f_swiginit(self, _SH.new__cv_numpy_sizeof_Vec3f())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec3f

# Register _cv_numpy_sizeof_Vec3f in _SH:
_SH._cv_numpy_sizeof_Vec3f_swigregister(_cv_numpy_sizeof_Vec3f)


if _cv_numpy_sizeof_Vec3f.value == 1:
    _cv_numpy_typestr_map["Vec3f"] = "|" +"f" + "1"
else:
    _cv_numpy_typestr_map["Vec3f"] = _cv_numpy_endianess  +"f" + str(_cv_numpy_sizeof_Vec3f.value)

class _Mat__Vec3f(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec3f_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec3f_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec3f_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec3f_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec3f_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec3f_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec3f_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec3f_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec3f_type(self)

    def depth(self):
        return _SH._Mat__Vec3f_depth(self)

    def channels(self):
        return _SH._Mat__Vec3f_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec3f_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec3f_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec3f_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec3f___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec3f_swiginit(self, _SH.new__Mat__Vec3f(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec3f___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec3f

# Register _Mat__Vec3f in _SH:
_SH._Mat__Vec3f_swigregister(_Mat__Vec3f)


Mat3f = _Mat__Vec3f

class _cv_numpy_sizeof_Vec4f(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec4f_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec4f_swiginit(self, _SH.new__cv_numpy_sizeof_Vec4f())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec4f

# Register _cv_numpy_sizeof_Vec4f in _SH:
_SH._cv_numpy_sizeof_Vec4f_swigregister(_cv_numpy_sizeof_Vec4f)


if _cv_numpy_sizeof_Vec4f.value == 1:
    _cv_numpy_typestr_map["Vec4f"] = "|" +"f" + "1"
else:
    _cv_numpy_typestr_map["Vec4f"] = _cv_numpy_endianess  +"f" + str(_cv_numpy_sizeof_Vec4f.value)

class _Mat__Vec4f(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec4f_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec4f_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec4f_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec4f_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec4f_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec4f_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec4f_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec4f_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec4f_type(self)

    def depth(self):
        return _SH._Mat__Vec4f_depth(self)

    def channels(self):
        return _SH._Mat__Vec4f_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec4f_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec4f_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec4f_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec4f___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec4f_swiginit(self, _SH.new__Mat__Vec4f(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec4f___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec4f

# Register _Mat__Vec4f in _SH:
_SH._Mat__Vec4f_swigregister(_Mat__Vec4f)


Mat4f = _Mat__Vec4f

class _Mat__double(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__double_create(self, *args)

    def cross(self, m):
        return _SH._Mat__double_cross(self, m)

    def row(self, y):
        return _SH._Mat__double_row(self, y)

    def col(self, x):
        return _SH._Mat__double_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__double_diag(self, d)

    def clone(self):
        return _SH._Mat__double_clone(self)

    def elemSize(self):
        return _SH._Mat__double_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__double_elemSize1(self)

    def type(self):
        return _SH._Mat__double_type(self)

    def depth(self):
        return _SH._Mat__double_depth(self)

    def channels(self):
        return _SH._Mat__double_channels(self)

    def step1(self, i=0):
        return _SH._Mat__double_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__double_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__double_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__double___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__double_swiginit(self, _SH.new__Mat__double(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__double___str__(self)
    __swig_destroy__ = _SH.delete__Mat__double

# Register _Mat__double in _SH:
_SH._Mat__double_swigregister(_Mat__double)


Mat1d = _Mat__double

class _cv_numpy_sizeof_Vec2d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec2d_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec2d_swiginit(self, _SH.new__cv_numpy_sizeof_Vec2d())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec2d

# Register _cv_numpy_sizeof_Vec2d in _SH:
_SH._cv_numpy_sizeof_Vec2d_swigregister(_cv_numpy_sizeof_Vec2d)


if _cv_numpy_sizeof_Vec2d.value == 1:
    _cv_numpy_typestr_map["Vec2d"] = "|" +"f" + "1"
else:
    _cv_numpy_typestr_map["Vec2d"] = _cv_numpy_endianess  +"f" + str(_cv_numpy_sizeof_Vec2d.value)

class _Mat__Vec2d(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec2d_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec2d_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec2d_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec2d_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec2d_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec2d_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec2d_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec2d_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec2d_type(self)

    def depth(self):
        return _SH._Mat__Vec2d_depth(self)

    def channels(self):
        return _SH._Mat__Vec2d_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec2d_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec2d_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec2d_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec2d___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec2d_swiginit(self, _SH.new__Mat__Vec2d(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec2d___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec2d

# Register _Mat__Vec2d in _SH:
_SH._Mat__Vec2d_swigregister(_Mat__Vec2d)


Mat2d = _Mat__Vec2d

class _cv_numpy_sizeof_Vec3d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec3d_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec3d_swiginit(self, _SH.new__cv_numpy_sizeof_Vec3d())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec3d

# Register _cv_numpy_sizeof_Vec3d in _SH:
_SH._cv_numpy_sizeof_Vec3d_swigregister(_cv_numpy_sizeof_Vec3d)


if _cv_numpy_sizeof_Vec3d.value == 1:
    _cv_numpy_typestr_map["Vec3d"] = "|" +"f" + "1"
else:
    _cv_numpy_typestr_map["Vec3d"] = _cv_numpy_endianess  +"f" + str(_cv_numpy_sizeof_Vec3d.value)

class _Mat__Vec3d(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec3d_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec3d_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec3d_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec3d_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec3d_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec3d_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec3d_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec3d_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec3d_type(self)

    def depth(self):
        return _SH._Mat__Vec3d_depth(self)

    def channels(self):
        return _SH._Mat__Vec3d_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec3d_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec3d_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec3d_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec3d___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec3d_swiginit(self, _SH.new__Mat__Vec3d(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec3d___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec3d

# Register _Mat__Vec3d in _SH:
_SH._Mat__Vec3d_swigregister(_Mat__Vec3d)


Mat3d = _Mat__Vec3d

class _cv_numpy_sizeof_Vec4d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = _SH._cv_numpy_sizeof_Vec4d_value

    def __init__(self):
        _SH._cv_numpy_sizeof_Vec4d_swiginit(self, _SH.new__cv_numpy_sizeof_Vec4d())
    __swig_destroy__ = _SH.delete__cv_numpy_sizeof_Vec4d

# Register _cv_numpy_sizeof_Vec4d in _SH:
_SH._cv_numpy_sizeof_Vec4d_swigregister(_cv_numpy_sizeof_Vec4d)


if _cv_numpy_sizeof_Vec4d.value == 1:
    _cv_numpy_typestr_map["Vec4d"] = "|" +"f" + "1"
else:
    _cv_numpy_typestr_map["Vec4d"] = _cv_numpy_endianess  +"f" + str(_cv_numpy_sizeof_Vec4d.value)

class _Mat__Vec4d(Mat):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def create(self, *args):
        return _SH._Mat__Vec4d_create(self, *args)

    def cross(self, m):
        return _SH._Mat__Vec4d_cross(self, m)

    def row(self, y):
        return _SH._Mat__Vec4d_row(self, y)

    def col(self, x):
        return _SH._Mat__Vec4d_col(self, x)

    def diag(self, d=0):
        return _SH._Mat__Vec4d_diag(self, d)

    def clone(self):
        return _SH._Mat__Vec4d_clone(self)

    def elemSize(self):
        return _SH._Mat__Vec4d_elemSize(self)

    def elemSize1(self):
        return _SH._Mat__Vec4d_elemSize1(self)

    def type(self):
        return _SH._Mat__Vec4d_type(self)

    def depth(self):
        return _SH._Mat__Vec4d_depth(self)

    def channels(self):
        return _SH._Mat__Vec4d_channels(self)

    def step1(self, i=0):
        return _SH._Mat__Vec4d_step1(self, i)

    def stepT(self, i=0):
        return _SH._Mat__Vec4d_stepT(self, i)

    def adjustROI(self, dtop, dbottom, dleft, dright):
        return _SH._Mat__Vec4d_adjustROI(self, dtop, dbottom, dleft, dright)

    def __call__(self, *args):
        return _SH._Mat__Vec4d___call__(self, *args)

    def __init__(self, *args):
        _SH._Mat__Vec4d_swiginit(self, _SH.new__Mat__Vec4d(*args))

    @classmethod
    def __check_channels_compatibility(cls, array):
        obj = cls()
        n_channel = obj.channels()

        if n_channel == 1:
            if len(array.shape) != 2:
                raise ValueError("{} expects a 2-dimensional numpy ndarray.".format(cls))
        else:
            if len(array.shape) != 3:
                raise ValueError("{} expects a 3-dimensional numpy ndarray.".format(cls))
            elif array.shape[2] != n_channel:
                raise ValueError("{} expects the last ndarray dimension to have a size of {}".format(cls, n_channel))

    @classmethod
    def from_array(cls, array):
        import numpy as np
        array = np.asarray(array)

        if cls()._typestr() != array.__array_interface__['typestr']:
            raise ValueError("{} expects a {} datatype.".format(cls, cls()._typestr()))

        cls.__check_channels_compatibility(array)

        new_mat = cls(_mat__np_array_constructor(),
                      array.shape[0],
                      array.shape[1],
                      array.__array_interface__['data'][0])

    # Holds an internal reference to keep the image buffer alive
        new_mat._array = array

        return new_mat


    def __str__(self):
        return _SH._Mat__Vec4d___str__(self)
    __swig_destroy__ = _SH.delete__Mat__Vec4d

# Register _Mat__Vec4d in _SH:
_SH._Mat__Vec4d_swigregister(_Mat__Vec4d)


Mat4d = _Mat__Vec4d

class _Matx_float_1_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_1_2_rows
    cols = _SH._Matx_float_1_2_cols
    channels = _SH._Matx_float_1_2_channels
    shortdim = _SH._Matx_float_1_2_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_1_2_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_1_2_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_1_2_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_1_2_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_1_2_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_1_2_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_1_2_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_1_2_ddot(self, v)

    def t(self):
        return _SH._Matx_float_1_2_t(self)

    def mul(self, a):
        return _SH._Matx_float_1_2_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_1_2_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_1_2___call__(self, i, j)
    val = property(_SH._Matx_float_1_2_val_get, _SH._Matx_float_1_2_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_1_2_swiginit(self, _SH.new__Matx_float_1_2(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_1_2___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_1_2

# Register _Matx_float_1_2 in _SH:
_SH._Matx_float_1_2_swigregister(_Matx_float_1_2)

def _Matx_float_1_2_all(alpha):
    return _SH._Matx_float_1_2_all(alpha)

def _Matx_float_1_2_zeros():
    return _SH._Matx_float_1_2_zeros()

def _Matx_float_1_2_ones():
    return _SH._Matx_float_1_2_ones()

def _Matx_float_1_2_eye():
    return _SH._Matx_float_1_2_eye()

def _Matx_float_1_2_randu(a, b):
    return _SH._Matx_float_1_2_randu(a, b)

def _Matx_float_1_2_randn(a, b):
    return _SH._Matx_float_1_2_randn(a, b)


Matx12f = _Matx_float_1_2

class _Matx_double_1_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_1_2_rows
    cols = _SH._Matx_double_1_2_cols
    channels = _SH._Matx_double_1_2_channels
    shortdim = _SH._Matx_double_1_2_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_1_2_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_1_2_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_1_2_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_1_2_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_1_2_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_1_2_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_1_2_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_1_2_ddot(self, v)

    def t(self):
        return _SH._Matx_double_1_2_t(self)

    def mul(self, a):
        return _SH._Matx_double_1_2_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_1_2_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_1_2___call__(self, i, j)
    val = property(_SH._Matx_double_1_2_val_get, _SH._Matx_double_1_2_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_1_2_swiginit(self, _SH.new__Matx_double_1_2(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_1_2___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_1_2

# Register _Matx_double_1_2 in _SH:
_SH._Matx_double_1_2_swigregister(_Matx_double_1_2)

def _Matx_double_1_2_all(alpha):
    return _SH._Matx_double_1_2_all(alpha)

def _Matx_double_1_2_zeros():
    return _SH._Matx_double_1_2_zeros()

def _Matx_double_1_2_ones():
    return _SH._Matx_double_1_2_ones()

def _Matx_double_1_2_eye():
    return _SH._Matx_double_1_2_eye()

def _Matx_double_1_2_randu(a, b):
    return _SH._Matx_double_1_2_randu(a, b)

def _Matx_double_1_2_randn(a, b):
    return _SH._Matx_double_1_2_randn(a, b)


Matx12d = _Matx_double_1_2

class _Matx_float_1_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_1_3_rows
    cols = _SH._Matx_float_1_3_cols
    channels = _SH._Matx_float_1_3_channels
    shortdim = _SH._Matx_float_1_3_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_1_3_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_1_3_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_1_3_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_1_3_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_1_3_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_1_3_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_1_3_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_1_3_ddot(self, v)

    def t(self):
        return _SH._Matx_float_1_3_t(self)

    def mul(self, a):
        return _SH._Matx_float_1_3_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_1_3_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_1_3___call__(self, i, j)
    val = property(_SH._Matx_float_1_3_val_get, _SH._Matx_float_1_3_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_1_3_swiginit(self, _SH.new__Matx_float_1_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_1_3___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_1_3

# Register _Matx_float_1_3 in _SH:
_SH._Matx_float_1_3_swigregister(_Matx_float_1_3)

def _Matx_float_1_3_all(alpha):
    return _SH._Matx_float_1_3_all(alpha)

def _Matx_float_1_3_zeros():
    return _SH._Matx_float_1_3_zeros()

def _Matx_float_1_3_ones():
    return _SH._Matx_float_1_3_ones()

def _Matx_float_1_3_eye():
    return _SH._Matx_float_1_3_eye()

def _Matx_float_1_3_randu(a, b):
    return _SH._Matx_float_1_3_randu(a, b)

def _Matx_float_1_3_randn(a, b):
    return _SH._Matx_float_1_3_randn(a, b)


Matx13f = _Matx_float_1_3

class _Matx_double_1_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_1_3_rows
    cols = _SH._Matx_double_1_3_cols
    channels = _SH._Matx_double_1_3_channels
    shortdim = _SH._Matx_double_1_3_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_1_3_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_1_3_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_1_3_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_1_3_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_1_3_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_1_3_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_1_3_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_1_3_ddot(self, v)

    def t(self):
        return _SH._Matx_double_1_3_t(self)

    def mul(self, a):
        return _SH._Matx_double_1_3_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_1_3_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_1_3___call__(self, i, j)
    val = property(_SH._Matx_double_1_3_val_get, _SH._Matx_double_1_3_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_1_3_swiginit(self, _SH.new__Matx_double_1_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_1_3___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_1_3

# Register _Matx_double_1_3 in _SH:
_SH._Matx_double_1_3_swigregister(_Matx_double_1_3)

def _Matx_double_1_3_all(alpha):
    return _SH._Matx_double_1_3_all(alpha)

def _Matx_double_1_3_zeros():
    return _SH._Matx_double_1_3_zeros()

def _Matx_double_1_3_ones():
    return _SH._Matx_double_1_3_ones()

def _Matx_double_1_3_eye():
    return _SH._Matx_double_1_3_eye()

def _Matx_double_1_3_randu(a, b):
    return _SH._Matx_double_1_3_randu(a, b)

def _Matx_double_1_3_randn(a, b):
    return _SH._Matx_double_1_3_randn(a, b)


Matx13d = _Matx_double_1_3

class _Matx_float_1_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_1_4_rows
    cols = _SH._Matx_float_1_4_cols
    channels = _SH._Matx_float_1_4_channels
    shortdim = _SH._Matx_float_1_4_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_1_4_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_1_4_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_1_4_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_1_4_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_1_4_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_1_4_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_1_4_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_1_4_ddot(self, v)

    def t(self):
        return _SH._Matx_float_1_4_t(self)

    def mul(self, a):
        return _SH._Matx_float_1_4_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_1_4_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_1_4___call__(self, i, j)
    val = property(_SH._Matx_float_1_4_val_get, _SH._Matx_float_1_4_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_1_4_swiginit(self, _SH.new__Matx_float_1_4(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_1_4___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_1_4

# Register _Matx_float_1_4 in _SH:
_SH._Matx_float_1_4_swigregister(_Matx_float_1_4)

def _Matx_float_1_4_all(alpha):
    return _SH._Matx_float_1_4_all(alpha)

def _Matx_float_1_4_zeros():
    return _SH._Matx_float_1_4_zeros()

def _Matx_float_1_4_ones():
    return _SH._Matx_float_1_4_ones()

def _Matx_float_1_4_eye():
    return _SH._Matx_float_1_4_eye()

def _Matx_float_1_4_randu(a, b):
    return _SH._Matx_float_1_4_randu(a, b)

def _Matx_float_1_4_randn(a, b):
    return _SH._Matx_float_1_4_randn(a, b)


Matx14f = _Matx_float_1_4

class _Matx_double_1_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_1_4_rows
    cols = _SH._Matx_double_1_4_cols
    channels = _SH._Matx_double_1_4_channels
    shortdim = _SH._Matx_double_1_4_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_1_4_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_1_4_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_1_4_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_1_4_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_1_4_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_1_4_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_1_4_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_1_4_ddot(self, v)

    def t(self):
        return _SH._Matx_double_1_4_t(self)

    def mul(self, a):
        return _SH._Matx_double_1_4_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_1_4_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_1_4___call__(self, i, j)
    val = property(_SH._Matx_double_1_4_val_get, _SH._Matx_double_1_4_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_1_4_swiginit(self, _SH.new__Matx_double_1_4(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_1_4___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_1_4

# Register _Matx_double_1_4 in _SH:
_SH._Matx_double_1_4_swigregister(_Matx_double_1_4)

def _Matx_double_1_4_all(alpha):
    return _SH._Matx_double_1_4_all(alpha)

def _Matx_double_1_4_zeros():
    return _SH._Matx_double_1_4_zeros()

def _Matx_double_1_4_ones():
    return _SH._Matx_double_1_4_ones()

def _Matx_double_1_4_eye():
    return _SH._Matx_double_1_4_eye()

def _Matx_double_1_4_randu(a, b):
    return _SH._Matx_double_1_4_randu(a, b)

def _Matx_double_1_4_randn(a, b):
    return _SH._Matx_double_1_4_randn(a, b)


Matx14d = _Matx_double_1_4

class _Matx_float_1_6(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_1_6_rows
    cols = _SH._Matx_float_1_6_cols
    channels = _SH._Matx_float_1_6_channels
    shortdim = _SH._Matx_float_1_6_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_1_6_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_1_6_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_1_6_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_1_6_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_1_6_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_1_6_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_1_6_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_1_6_ddot(self, v)

    def t(self):
        return _SH._Matx_float_1_6_t(self)

    def mul(self, a):
        return _SH._Matx_float_1_6_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_1_6_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_1_6___call__(self, i, j)
    val = property(_SH._Matx_float_1_6_val_get, _SH._Matx_float_1_6_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_1_6_swiginit(self, _SH.new__Matx_float_1_6(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_1_6___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_1_6

# Register _Matx_float_1_6 in _SH:
_SH._Matx_float_1_6_swigregister(_Matx_float_1_6)

def _Matx_float_1_6_all(alpha):
    return _SH._Matx_float_1_6_all(alpha)

def _Matx_float_1_6_zeros():
    return _SH._Matx_float_1_6_zeros()

def _Matx_float_1_6_ones():
    return _SH._Matx_float_1_6_ones()

def _Matx_float_1_6_eye():
    return _SH._Matx_float_1_6_eye()

def _Matx_float_1_6_randu(a, b):
    return _SH._Matx_float_1_6_randu(a, b)

def _Matx_float_1_6_randn(a, b):
    return _SH._Matx_float_1_6_randn(a, b)


Matx16f = _Matx_float_1_6

class _Matx_double_1_6(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_1_6_rows
    cols = _SH._Matx_double_1_6_cols
    channels = _SH._Matx_double_1_6_channels
    shortdim = _SH._Matx_double_1_6_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_1_6_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_1_6_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_1_6_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_1_6_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_1_6_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_1_6_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_1_6_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_1_6_ddot(self, v)

    def t(self):
        return _SH._Matx_double_1_6_t(self)

    def mul(self, a):
        return _SH._Matx_double_1_6_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_1_6_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_1_6___call__(self, i, j)
    val = property(_SH._Matx_double_1_6_val_get, _SH._Matx_double_1_6_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_1_6_swiginit(self, _SH.new__Matx_double_1_6(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_1_6___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_1_6

# Register _Matx_double_1_6 in _SH:
_SH._Matx_double_1_6_swigregister(_Matx_double_1_6)

def _Matx_double_1_6_all(alpha):
    return _SH._Matx_double_1_6_all(alpha)

def _Matx_double_1_6_zeros():
    return _SH._Matx_double_1_6_zeros()

def _Matx_double_1_6_ones():
    return _SH._Matx_double_1_6_ones()

def _Matx_double_1_6_eye():
    return _SH._Matx_double_1_6_eye()

def _Matx_double_1_6_randu(a, b):
    return _SH._Matx_double_1_6_randu(a, b)

def _Matx_double_1_6_randn(a, b):
    return _SH._Matx_double_1_6_randn(a, b)


Matx16d = _Matx_double_1_6

class _Matx_float_2_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_2_2_rows
    cols = _SH._Matx_float_2_2_cols
    channels = _SH._Matx_float_2_2_channels
    shortdim = _SH._Matx_float_2_2_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_2_2_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_2_2_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_2_2_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_2_2_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_2_2_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_2_2_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_2_2_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_2_2_ddot(self, v)

    def t(self):
        return _SH._Matx_float_2_2_t(self)

    def mul(self, a):
        return _SH._Matx_float_2_2_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_2_2_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_2_2___call__(self, i, j)
    val = property(_SH._Matx_float_2_2_val_get, _SH._Matx_float_2_2_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_2_2_swiginit(self, _SH.new__Matx_float_2_2(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_2_2___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_2_2

# Register _Matx_float_2_2 in _SH:
_SH._Matx_float_2_2_swigregister(_Matx_float_2_2)

def _Matx_float_2_2_all(alpha):
    return _SH._Matx_float_2_2_all(alpha)

def _Matx_float_2_2_zeros():
    return _SH._Matx_float_2_2_zeros()

def _Matx_float_2_2_ones():
    return _SH._Matx_float_2_2_ones()

def _Matx_float_2_2_eye():
    return _SH._Matx_float_2_2_eye()

def _Matx_float_2_2_randu(a, b):
    return _SH._Matx_float_2_2_randu(a, b)

def _Matx_float_2_2_randn(a, b):
    return _SH._Matx_float_2_2_randn(a, b)


Matx22f = _Matx_float_2_2

class _Matx_double_2_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_2_2_rows
    cols = _SH._Matx_double_2_2_cols
    channels = _SH._Matx_double_2_2_channels
    shortdim = _SH._Matx_double_2_2_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_2_2_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_2_2_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_2_2_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_2_2_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_2_2_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_2_2_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_2_2_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_2_2_ddot(self, v)

    def t(self):
        return _SH._Matx_double_2_2_t(self)

    def mul(self, a):
        return _SH._Matx_double_2_2_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_2_2_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_2_2___call__(self, i, j)
    val = property(_SH._Matx_double_2_2_val_get, _SH._Matx_double_2_2_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_2_2_swiginit(self, _SH.new__Matx_double_2_2(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_2_2___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_2_2

# Register _Matx_double_2_2 in _SH:
_SH._Matx_double_2_2_swigregister(_Matx_double_2_2)

def _Matx_double_2_2_all(alpha):
    return _SH._Matx_double_2_2_all(alpha)

def _Matx_double_2_2_zeros():
    return _SH._Matx_double_2_2_zeros()

def _Matx_double_2_2_ones():
    return _SH._Matx_double_2_2_ones()

def _Matx_double_2_2_eye():
    return _SH._Matx_double_2_2_eye()

def _Matx_double_2_2_randu(a, b):
    return _SH._Matx_double_2_2_randu(a, b)

def _Matx_double_2_2_randn(a, b):
    return _SH._Matx_double_2_2_randn(a, b)


Matx22d = _Matx_double_2_2

class _Matx_float_2_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_2_3_rows
    cols = _SH._Matx_float_2_3_cols
    channels = _SH._Matx_float_2_3_channels
    shortdim = _SH._Matx_float_2_3_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_2_3_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_2_3_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_2_3_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_2_3_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_2_3_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_2_3_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_2_3_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_2_3_ddot(self, v)

    def t(self):
        return _SH._Matx_float_2_3_t(self)

    def mul(self, a):
        return _SH._Matx_float_2_3_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_2_3_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_2_3___call__(self, i, j)
    val = property(_SH._Matx_float_2_3_val_get, _SH._Matx_float_2_3_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_2_3_swiginit(self, _SH.new__Matx_float_2_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_2_3___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_2_3

# Register _Matx_float_2_3 in _SH:
_SH._Matx_float_2_3_swigregister(_Matx_float_2_3)

def _Matx_float_2_3_all(alpha):
    return _SH._Matx_float_2_3_all(alpha)

def _Matx_float_2_3_zeros():
    return _SH._Matx_float_2_3_zeros()

def _Matx_float_2_3_ones():
    return _SH._Matx_float_2_3_ones()

def _Matx_float_2_3_eye():
    return _SH._Matx_float_2_3_eye()

def _Matx_float_2_3_randu(a, b):
    return _SH._Matx_float_2_3_randu(a, b)

def _Matx_float_2_3_randn(a, b):
    return _SH._Matx_float_2_3_randn(a, b)


Matx23f = _Matx_float_2_3

class _Matx_double_2_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_2_3_rows
    cols = _SH._Matx_double_2_3_cols
    channels = _SH._Matx_double_2_3_channels
    shortdim = _SH._Matx_double_2_3_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_2_3_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_2_3_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_2_3_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_2_3_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_2_3_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_2_3_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_2_3_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_2_3_ddot(self, v)

    def t(self):
        return _SH._Matx_double_2_3_t(self)

    def mul(self, a):
        return _SH._Matx_double_2_3_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_2_3_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_2_3___call__(self, i, j)
    val = property(_SH._Matx_double_2_3_val_get, _SH._Matx_double_2_3_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_2_3_swiginit(self, _SH.new__Matx_double_2_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_2_3___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_2_3

# Register _Matx_double_2_3 in _SH:
_SH._Matx_double_2_3_swigregister(_Matx_double_2_3)

def _Matx_double_2_3_all(alpha):
    return _SH._Matx_double_2_3_all(alpha)

def _Matx_double_2_3_zeros():
    return _SH._Matx_double_2_3_zeros()

def _Matx_double_2_3_ones():
    return _SH._Matx_double_2_3_ones()

def _Matx_double_2_3_eye():
    return _SH._Matx_double_2_3_eye()

def _Matx_double_2_3_randu(a, b):
    return _SH._Matx_double_2_3_randu(a, b)

def _Matx_double_2_3_randn(a, b):
    return _SH._Matx_double_2_3_randn(a, b)


Matx23d = _Matx_double_2_3

class _Matx_float_3_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_3_2_rows
    cols = _SH._Matx_float_3_2_cols
    channels = _SH._Matx_float_3_2_channels
    shortdim = _SH._Matx_float_3_2_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_3_2_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_3_2_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_3_2_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_3_2_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_3_2_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_3_2_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_3_2_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_3_2_ddot(self, v)

    def t(self):
        return _SH._Matx_float_3_2_t(self)

    def mul(self, a):
        return _SH._Matx_float_3_2_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_3_2_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_3_2___call__(self, i, j)
    val = property(_SH._Matx_float_3_2_val_get, _SH._Matx_float_3_2_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_3_2_swiginit(self, _SH.new__Matx_float_3_2(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_3_2___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_3_2

# Register _Matx_float_3_2 in _SH:
_SH._Matx_float_3_2_swigregister(_Matx_float_3_2)

def _Matx_float_3_2_all(alpha):
    return _SH._Matx_float_3_2_all(alpha)

def _Matx_float_3_2_zeros():
    return _SH._Matx_float_3_2_zeros()

def _Matx_float_3_2_ones():
    return _SH._Matx_float_3_2_ones()

def _Matx_float_3_2_eye():
    return _SH._Matx_float_3_2_eye()

def _Matx_float_3_2_randu(a, b):
    return _SH._Matx_float_3_2_randu(a, b)

def _Matx_float_3_2_randn(a, b):
    return _SH._Matx_float_3_2_randn(a, b)


Matx32f = _Matx_float_3_2

class _Matx_double_3_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_3_2_rows
    cols = _SH._Matx_double_3_2_cols
    channels = _SH._Matx_double_3_2_channels
    shortdim = _SH._Matx_double_3_2_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_3_2_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_3_2_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_3_2_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_3_2_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_3_2_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_3_2_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_3_2_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_3_2_ddot(self, v)

    def t(self):
        return _SH._Matx_double_3_2_t(self)

    def mul(self, a):
        return _SH._Matx_double_3_2_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_3_2_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_3_2___call__(self, i, j)
    val = property(_SH._Matx_double_3_2_val_get, _SH._Matx_double_3_2_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_3_2_swiginit(self, _SH.new__Matx_double_3_2(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_3_2___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_3_2

# Register _Matx_double_3_2 in _SH:
_SH._Matx_double_3_2_swigregister(_Matx_double_3_2)

def _Matx_double_3_2_all(alpha):
    return _SH._Matx_double_3_2_all(alpha)

def _Matx_double_3_2_zeros():
    return _SH._Matx_double_3_2_zeros()

def _Matx_double_3_2_ones():
    return _SH._Matx_double_3_2_ones()

def _Matx_double_3_2_eye():
    return _SH._Matx_double_3_2_eye()

def _Matx_double_3_2_randu(a, b):
    return _SH._Matx_double_3_2_randu(a, b)

def _Matx_double_3_2_randn(a, b):
    return _SH._Matx_double_3_2_randn(a, b)


Matx32d = _Matx_double_3_2

class _Matx_float_3_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_3_3_rows
    cols = _SH._Matx_float_3_3_cols
    channels = _SH._Matx_float_3_3_channels
    shortdim = _SH._Matx_float_3_3_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_3_3_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_3_3_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_3_3_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_3_3_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_3_3_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_3_3_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_3_3_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_3_3_ddot(self, v)

    def t(self):
        return _SH._Matx_float_3_3_t(self)

    def mul(self, a):
        return _SH._Matx_float_3_3_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_3_3_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_3_3___call__(self, i, j)
    val = property(_SH._Matx_float_3_3_val_get, _SH._Matx_float_3_3_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_3_3_swiginit(self, _SH.new__Matx_float_3_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_3_3___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_3_3

# Register _Matx_float_3_3 in _SH:
_SH._Matx_float_3_3_swigregister(_Matx_float_3_3)

def _Matx_float_3_3_all(alpha):
    return _SH._Matx_float_3_3_all(alpha)

def _Matx_float_3_3_zeros():
    return _SH._Matx_float_3_3_zeros()

def _Matx_float_3_3_ones():
    return _SH._Matx_float_3_3_ones()

def _Matx_float_3_3_eye():
    return _SH._Matx_float_3_3_eye()

def _Matx_float_3_3_randu(a, b):
    return _SH._Matx_float_3_3_randu(a, b)

def _Matx_float_3_3_randn(a, b):
    return _SH._Matx_float_3_3_randn(a, b)


Matx33f = _Matx_float_3_3

class _Matx_double_3_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_3_3_rows
    cols = _SH._Matx_double_3_3_cols
    channels = _SH._Matx_double_3_3_channels
    shortdim = _SH._Matx_double_3_3_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_3_3_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_3_3_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_3_3_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_3_3_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_3_3_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_3_3_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_3_3_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_3_3_ddot(self, v)

    def t(self):
        return _SH._Matx_double_3_3_t(self)

    def mul(self, a):
        return _SH._Matx_double_3_3_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_3_3_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_3_3___call__(self, i, j)
    val = property(_SH._Matx_double_3_3_val_get, _SH._Matx_double_3_3_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_3_3_swiginit(self, _SH.new__Matx_double_3_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_3_3___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_3_3

# Register _Matx_double_3_3 in _SH:
_SH._Matx_double_3_3_swigregister(_Matx_double_3_3)

def _Matx_double_3_3_all(alpha):
    return _SH._Matx_double_3_3_all(alpha)

def _Matx_double_3_3_zeros():
    return _SH._Matx_double_3_3_zeros()

def _Matx_double_3_3_ones():
    return _SH._Matx_double_3_3_ones()

def _Matx_double_3_3_eye():
    return _SH._Matx_double_3_3_eye()

def _Matx_double_3_3_randu(a, b):
    return _SH._Matx_double_3_3_randu(a, b)

def _Matx_double_3_3_randn(a, b):
    return _SH._Matx_double_3_3_randn(a, b)


Matx33d = _Matx_double_3_3

class _Matx_float_3_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_3_4_rows
    cols = _SH._Matx_float_3_4_cols
    channels = _SH._Matx_float_3_4_channels
    shortdim = _SH._Matx_float_3_4_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_3_4_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_3_4_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_3_4_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_3_4_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_3_4_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_3_4_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_3_4_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_3_4_ddot(self, v)

    def t(self):
        return _SH._Matx_float_3_4_t(self)

    def mul(self, a):
        return _SH._Matx_float_3_4_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_3_4_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_3_4___call__(self, i, j)
    val = property(_SH._Matx_float_3_4_val_get, _SH._Matx_float_3_4_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_3_4_swiginit(self, _SH.new__Matx_float_3_4(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_3_4___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_3_4

# Register _Matx_float_3_4 in _SH:
_SH._Matx_float_3_4_swigregister(_Matx_float_3_4)

def _Matx_float_3_4_all(alpha):
    return _SH._Matx_float_3_4_all(alpha)

def _Matx_float_3_4_zeros():
    return _SH._Matx_float_3_4_zeros()

def _Matx_float_3_4_ones():
    return _SH._Matx_float_3_4_ones()

def _Matx_float_3_4_eye():
    return _SH._Matx_float_3_4_eye()

def _Matx_float_3_4_randu(a, b):
    return _SH._Matx_float_3_4_randu(a, b)

def _Matx_float_3_4_randn(a, b):
    return _SH._Matx_float_3_4_randn(a, b)


Matx34f = _Matx_float_3_4

class _Matx_double_3_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_3_4_rows
    cols = _SH._Matx_double_3_4_cols
    channels = _SH._Matx_double_3_4_channels
    shortdim = _SH._Matx_double_3_4_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_3_4_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_3_4_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_3_4_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_3_4_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_3_4_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_3_4_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_3_4_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_3_4_ddot(self, v)

    def t(self):
        return _SH._Matx_double_3_4_t(self)

    def mul(self, a):
        return _SH._Matx_double_3_4_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_3_4_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_3_4___call__(self, i, j)
    val = property(_SH._Matx_double_3_4_val_get, _SH._Matx_double_3_4_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_3_4_swiginit(self, _SH.new__Matx_double_3_4(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_3_4___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_3_4

# Register _Matx_double_3_4 in _SH:
_SH._Matx_double_3_4_swigregister(_Matx_double_3_4)

def _Matx_double_3_4_all(alpha):
    return _SH._Matx_double_3_4_all(alpha)

def _Matx_double_3_4_zeros():
    return _SH._Matx_double_3_4_zeros()

def _Matx_double_3_4_ones():
    return _SH._Matx_double_3_4_ones()

def _Matx_double_3_4_eye():
    return _SH._Matx_double_3_4_eye()

def _Matx_double_3_4_randu(a, b):
    return _SH._Matx_double_3_4_randu(a, b)

def _Matx_double_3_4_randn(a, b):
    return _SH._Matx_double_3_4_randn(a, b)


Matx34d = _Matx_double_3_4

class _Matx_float_4_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_4_3_rows
    cols = _SH._Matx_float_4_3_cols
    channels = _SH._Matx_float_4_3_channels
    shortdim = _SH._Matx_float_4_3_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_4_3_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_4_3_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_4_3_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_4_3_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_4_3_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_4_3_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_4_3_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_4_3_ddot(self, v)

    def t(self):
        return _SH._Matx_float_4_3_t(self)

    def mul(self, a):
        return _SH._Matx_float_4_3_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_4_3_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_4_3___call__(self, i, j)
    val = property(_SH._Matx_float_4_3_val_get, _SH._Matx_float_4_3_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_4_3_swiginit(self, _SH.new__Matx_float_4_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_4_3___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_4_3

# Register _Matx_float_4_3 in _SH:
_SH._Matx_float_4_3_swigregister(_Matx_float_4_3)

def _Matx_float_4_3_all(alpha):
    return _SH._Matx_float_4_3_all(alpha)

def _Matx_float_4_3_zeros():
    return _SH._Matx_float_4_3_zeros()

def _Matx_float_4_3_ones():
    return _SH._Matx_float_4_3_ones()

def _Matx_float_4_3_eye():
    return _SH._Matx_float_4_3_eye()

def _Matx_float_4_3_randu(a, b):
    return _SH._Matx_float_4_3_randu(a, b)

def _Matx_float_4_3_randn(a, b):
    return _SH._Matx_float_4_3_randn(a, b)


Matx43f = _Matx_float_4_3

class _Matx_double_4_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_4_3_rows
    cols = _SH._Matx_double_4_3_cols
    channels = _SH._Matx_double_4_3_channels
    shortdim = _SH._Matx_double_4_3_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_4_3_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_4_3_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_4_3_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_4_3_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_4_3_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_4_3_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_4_3_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_4_3_ddot(self, v)

    def t(self):
        return _SH._Matx_double_4_3_t(self)

    def mul(self, a):
        return _SH._Matx_double_4_3_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_4_3_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_4_3___call__(self, i, j)
    val = property(_SH._Matx_double_4_3_val_get, _SH._Matx_double_4_3_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_4_3_swiginit(self, _SH.new__Matx_double_4_3(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_4_3___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_4_3

# Register _Matx_double_4_3 in _SH:
_SH._Matx_double_4_3_swigregister(_Matx_double_4_3)

def _Matx_double_4_3_all(alpha):
    return _SH._Matx_double_4_3_all(alpha)

def _Matx_double_4_3_zeros():
    return _SH._Matx_double_4_3_zeros()

def _Matx_double_4_3_ones():
    return _SH._Matx_double_4_3_ones()

def _Matx_double_4_3_eye():
    return _SH._Matx_double_4_3_eye()

def _Matx_double_4_3_randu(a, b):
    return _SH._Matx_double_4_3_randu(a, b)

def _Matx_double_4_3_randn(a, b):
    return _SH._Matx_double_4_3_randn(a, b)


Matx43d = _Matx_double_4_3

class _Matx_float_4_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_4_4_rows
    cols = _SH._Matx_float_4_4_cols
    channels = _SH._Matx_float_4_4_channels
    shortdim = _SH._Matx_float_4_4_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_4_4_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_4_4_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_4_4_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_4_4_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_4_4_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_4_4_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_4_4_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_4_4_ddot(self, v)

    def t(self):
        return _SH._Matx_float_4_4_t(self)

    def mul(self, a):
        return _SH._Matx_float_4_4_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_4_4_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_4_4___call__(self, i, j)
    val = property(_SH._Matx_float_4_4_val_get, _SH._Matx_float_4_4_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_4_4_swiginit(self, _SH.new__Matx_float_4_4(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_4_4___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_4_4

# Register _Matx_float_4_4 in _SH:
_SH._Matx_float_4_4_swigregister(_Matx_float_4_4)

def _Matx_float_4_4_all(alpha):
    return _SH._Matx_float_4_4_all(alpha)

def _Matx_float_4_4_zeros():
    return _SH._Matx_float_4_4_zeros()

def _Matx_float_4_4_ones():
    return _SH._Matx_float_4_4_ones()

def _Matx_float_4_4_eye():
    return _SH._Matx_float_4_4_eye()

def _Matx_float_4_4_randu(a, b):
    return _SH._Matx_float_4_4_randu(a, b)

def _Matx_float_4_4_randn(a, b):
    return _SH._Matx_float_4_4_randn(a, b)


Matx44f = _Matx_float_4_4

class _Matx_double_4_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_4_4_rows
    cols = _SH._Matx_double_4_4_cols
    channels = _SH._Matx_double_4_4_channels
    shortdim = _SH._Matx_double_4_4_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_4_4_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_4_4_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_4_4_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_4_4_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_4_4_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_4_4_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_4_4_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_4_4_ddot(self, v)

    def t(self):
        return _SH._Matx_double_4_4_t(self)

    def mul(self, a):
        return _SH._Matx_double_4_4_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_4_4_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_4_4___call__(self, i, j)
    val = property(_SH._Matx_double_4_4_val_get, _SH._Matx_double_4_4_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_4_4_swiginit(self, _SH.new__Matx_double_4_4(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_4_4___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_4_4

# Register _Matx_double_4_4 in _SH:
_SH._Matx_double_4_4_swigregister(_Matx_double_4_4)

def _Matx_double_4_4_all(alpha):
    return _SH._Matx_double_4_4_all(alpha)

def _Matx_double_4_4_zeros():
    return _SH._Matx_double_4_4_zeros()

def _Matx_double_4_4_ones():
    return _SH._Matx_double_4_4_ones()

def _Matx_double_4_4_eye():
    return _SH._Matx_double_4_4_eye()

def _Matx_double_4_4_randu(a, b):
    return _SH._Matx_double_4_4_randu(a, b)

def _Matx_double_4_4_randn(a, b):
    return _SH._Matx_double_4_4_randn(a, b)


Matx44d = _Matx_double_4_4

class _Matx_float_6_6(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_float_6_6_rows
    cols = _SH._Matx_float_6_6_cols
    channels = _SH._Matx_float_6_6_channels
    shortdim = _SH._Matx_float_6_6_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_float_6_6_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_float_6_6_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_float_6_6_ones()

    @staticmethod
    def eye():
        return _SH._Matx_float_6_6_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_float_6_6_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_float_6_6_randn(a, b)

    def dot(self, v):
        return _SH._Matx_float_6_6_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_float_6_6_ddot(self, v)

    def t(self):
        return _SH._Matx_float_6_6_t(self)

    def mul(self, a):
        return _SH._Matx_float_6_6_mul(self, a)

    def div(self, a):
        return _SH._Matx_float_6_6_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_float_6_6___call__(self, i, j)
    val = property(_SH._Matx_float_6_6_val_get, _SH._Matx_float_6_6_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_float_6_6_swiginit(self, _SH.new__Matx_float_6_6(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_float_6_6___str__(self)
    __swig_destroy__ = _SH.delete__Matx_float_6_6

# Register _Matx_float_6_6 in _SH:
_SH._Matx_float_6_6_swigregister(_Matx_float_6_6)

def _Matx_float_6_6_all(alpha):
    return _SH._Matx_float_6_6_all(alpha)

def _Matx_float_6_6_zeros():
    return _SH._Matx_float_6_6_zeros()

def _Matx_float_6_6_ones():
    return _SH._Matx_float_6_6_ones()

def _Matx_float_6_6_eye():
    return _SH._Matx_float_6_6_eye()

def _Matx_float_6_6_randu(a, b):
    return _SH._Matx_float_6_6_randu(a, b)

def _Matx_float_6_6_randn(a, b):
    return _SH._Matx_float_6_6_randn(a, b)


Matx66f = _Matx_float_6_6

class _Matx_double_6_6(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rows = _SH._Matx_double_6_6_rows
    cols = _SH._Matx_double_6_6_cols
    channels = _SH._Matx_double_6_6_channels
    shortdim = _SH._Matx_double_6_6_shortdim

    @staticmethod
    def all(alpha):
        return _SH._Matx_double_6_6_all(alpha)

    @staticmethod
    def zeros():
        return _SH._Matx_double_6_6_zeros()

    @staticmethod
    def ones():
        return _SH._Matx_double_6_6_ones()

    @staticmethod
    def eye():
        return _SH._Matx_double_6_6_eye()

    @staticmethod
    def randu(a, b):
        return _SH._Matx_double_6_6_randu(a, b)

    @staticmethod
    def randn(a, b):
        return _SH._Matx_double_6_6_randn(a, b)

    def dot(self, v):
        return _SH._Matx_double_6_6_dot(self, v)

    def ddot(self, v):
        return _SH._Matx_double_6_6_ddot(self, v)

    def t(self):
        return _SH._Matx_double_6_6_t(self)

    def mul(self, a):
        return _SH._Matx_double_6_6_mul(self, a)

    def div(self, a):
        return _SH._Matx_double_6_6_div(self, a)

    def __call__(self, i, j):
        return _SH._Matx_double_6_6___call__(self, i, j)
    val = property(_SH._Matx_double_6_6_val_get, _SH._Matx_double_6_6_val_set)

    import re
    _re_pattern = re.compile("^_Matx_(?P<value_type>[a-zA-Z_][a-zA-Z0-9_]*)_(?P<rows>[0-9]+)_(?P<cols>[0-9]+)$")


    def __init__(self, *args):

        ma = self._re_pattern.match(self.__class__.__name__)
        value_type = ma.group("value_type")
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        array = _array_map[value_type](rows*cols)
        for i in range(len(args)):
            array[i] = args[i]

        args = [array]


        _SH._Matx_double_6_6_swiginit(self, _SH.new__Matx_double_6_6(*args))

    def __getattribute__(self, name):
        if name == "__array_interface__":
            ma = self._re_pattern.match(self.__class__.__name__)
            value_type = ma.group("value_type")
            rows = int(ma.group("rows"))
            cols = int(ma.group("cols"))
            return {"shape": (rows, cols),
                    "typestr": _cv_numpy_typestr_map[value_type],
                    "data": (int(self.val), False)}
        else:
            return object.__getattribute__(self, name)


    def __getitem__(self, key):
        ma = self._re_pattern.match(self.__class__.__name__)
        rows = int(ma.group("rows"))
        cols = int(ma.group("cols"))

        if isinstance(key, int):
            if rows != 1 and cols != 1:
                raise IndexError
            i = key
            j = 0
        elif isinstance(key, tuple) and len(key) == 2:
            i = key[0]
            j = key[1]
        else:
            raise TypeError

        if i >= rows or j >= cols:
            raise IndexError

        return self(i, j)


    def __str__(self):
        return _SH._Matx_double_6_6___str__(self)
    __swig_destroy__ = _SH.delete__Matx_double_6_6

# Register _Matx_double_6_6 in _SH:
_SH._Matx_double_6_6_swigregister(_Matx_double_6_6)

def _Matx_double_6_6_all(alpha):
    return _SH._Matx_double_6_6_all(alpha)

def _Matx_double_6_6_zeros():
    return _SH._Matx_double_6_6_zeros()

def _Matx_double_6_6_ones():
    return _SH._Matx_double_6_6_ones()

def _Matx_double_6_6_eye():
    return _SH._Matx_double_6_6_eye()

def _Matx_double_6_6_randu(a, b):
    return _SH._Matx_double_6_6_randu(a, b)

def _Matx_double_6_6_randn(a, b):
    return _SH._Matx_double_6_6_randn(a, b)


Matx66d = _Matx_double_6_6

class _Point__int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _SH._Point__int_swiginit(self, _SH.new__Point__int(*args))

    def dot(self, pt):
        return _SH._Point__int_dot(self, pt)

    def ddot(self, pt):
        return _SH._Point__int_ddot(self, pt)

    def cross(self, pt):
        return _SH._Point__int_cross(self, pt)
    x = property(_SH._Point__int_x_get, _SH._Point__int_x_set)
    y = property(_SH._Point__int_y_get, _SH._Point__int_y_set)

    def __iter__(self):
        return iter((self.x, self.y))


    def __str__(self):
        return _SH._Point__int___str__(self)
    __swig_destroy__ = _SH.delete__Point__int

# Register _Point__int in _SH:
_SH._Point__int_swigregister(_Point__int)


Point2i = _Point__int

class _Point__float(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _SH._Point__float_swiginit(self, _SH.new__Point__float(*args))

    def dot(self, pt):
        return _SH._Point__float_dot(self, pt)

    def ddot(self, pt):
        return _SH._Point__float_ddot(self, pt)

    def cross(self, pt):
        return _SH._Point__float_cross(self, pt)
    x = property(_SH._Point__float_x_get, _SH._Point__float_x_set)
    y = property(_SH._Point__float_y_get, _SH._Point__float_y_set)

    def __iter__(self):
        return iter((self.x, self.y))


    def __str__(self):
        return _SH._Point__float___str__(self)
    __swig_destroy__ = _SH.delete__Point__float

# Register _Point__float in _SH:
_SH._Point__float_swigregister(_Point__float)


Point2f = _Point__float

class _Point__double(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _SH._Point__double_swiginit(self, _SH.new__Point__double(*args))

    def dot(self, pt):
        return _SH._Point__double_dot(self, pt)

    def ddot(self, pt):
        return _SH._Point__double_ddot(self, pt)

    def cross(self, pt):
        return _SH._Point__double_cross(self, pt)
    x = property(_SH._Point__double_x_get, _SH._Point__double_x_set)
    y = property(_SH._Point__double_y_get, _SH._Point__double_y_set)

    def __iter__(self):
        return iter((self.x, self.y))


    def __str__(self):
        return _SH._Point__double___str__(self)
    __swig_destroy__ = _SH.delete__Point__double

# Register _Point__double in _SH:
_SH._Point__double_swigregister(_Point__double)


Point2d = _Point__double


Point = Point2i

class _Rect__int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _SH._Rect__int_swiginit(self, _SH.new__Rect__int(*args))

    def tl(self):
        return _SH._Rect__int_tl(self)

    def br(self):
        return _SH._Rect__int_br(self)

    def size(self):
        return _SH._Rect__int_size(self)

    def area(self):
        return _SH._Rect__int_area(self)

    def contains(self, pt):
        return _SH._Rect__int_contains(self, pt)
    x = property(_SH._Rect__int_x_get, _SH._Rect__int_x_set)
    y = property(_SH._Rect__int_y_get, _SH._Rect__int_y_set)
    width = property(_SH._Rect__int_width_get, _SH._Rect__int_width_set)
    height = property(_SH._Rect__int_height_get, _SH._Rect__int_height_set)

    def __iter__(self):
        return iter((self.x, self.y, self.width, self.height))


    def __str__(self):
        return _SH._Rect__int___str__(self)
    __swig_destroy__ = _SH.delete__Rect__int

# Register _Rect__int in _SH:
_SH._Rect__int_swigregister(_Rect__int)


Rect2i = _Rect__int

class _Rect__float(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _SH._Rect__float_swiginit(self, _SH.new__Rect__float(*args))

    def tl(self):
        return _SH._Rect__float_tl(self)

    def br(self):
        return _SH._Rect__float_br(self)

    def size(self):
        return _SH._Rect__float_size(self)

    def area(self):
        return _SH._Rect__float_area(self)

    def contains(self, pt):
        return _SH._Rect__float_contains(self, pt)
    x = property(_SH._Rect__float_x_get, _SH._Rect__float_x_set)
    y = property(_SH._Rect__float_y_get, _SH._Rect__float_y_set)
    width = property(_SH._Rect__float_width_get, _SH._Rect__float_width_set)
    height = property(_SH._Rect__float_height_get, _SH._Rect__float_height_set)

    def __iter__(self):
        return iter((self.x, self.y, self.width, self.height))


    def __str__(self):
        return _SH._Rect__float___str__(self)
    __swig_destroy__ = _SH.delete__Rect__float

# Register _Rect__float in _SH:
_SH._Rect__float_swigregister(_Rect__float)


Rect2f = _Rect__float

class _Rect__double(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _SH._Rect__double_swiginit(self, _SH.new__Rect__double(*args))

    def tl(self):
        return _SH._Rect__double_tl(self)

    def br(self):
        return _SH._Rect__double_br(self)

    def size(self):
        return _SH._Rect__double_size(self)

    def area(self):
        return _SH._Rect__double_area(self)

    def contains(self, pt):
        return _SH._Rect__double_contains(self, pt)
    x = property(_SH._Rect__double_x_get, _SH._Rect__double_x_set)
    y = property(_SH._Rect__double_y_get, _SH._Rect__double_y_set)
    width = property(_SH._Rect__double_width_get, _SH._Rect__double_width_set)
    height = property(_SH._Rect__double_height_get, _SH._Rect__double_height_set)

    def __iter__(self):
        return iter((self.x, self.y, self.width, self.height))


    def __str__(self):
        return _SH._Rect__double___str__(self)
    __swig_destroy__ = _SH.delete__Rect__double

# Register _Rect__double in _SH:
_SH._Rect__double_swigregister(_Rect__double)


Rect2d = _Rect__double


Rect = Rect2i

class _Scalar__double(_Vec_double_4):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _SH._Scalar__double_swiginit(self, _SH.new__Scalar__double(*args))

    @staticmethod
    def all(v0):
        return _SH._Scalar__double_all(v0)

    def mul(self, a, scale=1):
        return _SH._Scalar__double_mul(self, a, scale)

    def conj(self):
        return _SH._Scalar__double_conj(self)

    def isReal(self):
        return _SH._Scalar__double_isReal(self)

    def __iter__(self):
        return iter((self(0), self(1), self(2), self(3)))

    def __getitem__(self, key):
        if not isinstance(key, int):
            raise TypeError

        if key >= 4:
            raise IndexError

        return self(key)


    def __str__(self):
        return _SH._Scalar__double___str__(self)
    __swig_destroy__ = _SH.delete__Scalar__double

# Register _Scalar__double in _SH:
_SH._Scalar__double_swigregister(_Scalar__double)

def _Scalar__double_all(v0):
    return _SH._Scalar__double_all(v0)


Scalar4d = _Scalar__double


Scalar = Scalar4d

class _Size__int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _SH._Size__int_swiginit(self, _SH.new__Size__int(*args))

    def area(self):
        return _SH._Size__int_area(self)
    width = property(_SH._Size__int_width_get, _SH._Size__int_width_set)
    height = property(_SH._Size__int_height_get, _SH._Size__int_height_set)

    def __iter__(self):
        return iter((self.width, self.height))


    def __str__(self):
        return _SH._Size__int___str__(self)
    __swig_destroy__ = _SH.delete__Size__int

# Register _Size__int in _SH:
_SH._Size__int_swigregister(_Size__int)


Size2i = _Size__int

class _Size__float(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _SH._Size__float_swiginit(self, _SH.new__Size__float(*args))

    def area(self):
        return _SH._Size__float_area(self)
    width = property(_SH._Size__float_width_get, _SH._Size__float_width_set)
    height = property(_SH._Size__float_height_get, _SH._Size__float_height_set)

    def __iter__(self):
        return iter((self.width, self.height))


    def __str__(self):
        return _SH._Size__float___str__(self)
    __swig_destroy__ = _SH.delete__Size__float

# Register _Size__float in _SH:
_SH._Size__float_swigregister(_Size__float)


Size2f = _Size__float

class _Size__double(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _SH._Size__double_swiginit(self, _SH.new__Size__double(*args))

    def area(self):
        return _SH._Size__double_area(self)
    width = property(_SH._Size__double_width_get, _SH._Size__double_width_set)
    height = property(_SH._Size__double_height_get, _SH._Size__double_height_set)

    def __iter__(self):
        return iter((self.width, self.height))


    def __str__(self):
        return _SH._Size__double___str__(self)
    __swig_destroy__ = _SH.delete__Size__double

# Register _Size__double in _SH:
_SH._Size__double_swigregister(_Size__double)


Size2d = _Size__double


Size = Size2i


def SH(file1, file2, outfile):
    return _SH.SH(file1, file2, outfile)


